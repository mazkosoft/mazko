<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene Configurator</title>
    <!-- 引入 Tailwind CSS CDN，用于快速美观的布局和样式 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* 更深一点的背景，增加对比度 */
            color: #E0E0E0; /* 浅色文本 */
            min-height: 100vh;
            display: flex;
            position: relative; /* 用于叠加 */
            overflow-x: hidden; /* 防止水平滚动 */
        }
        #webgl-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute; /* 覆盖整个视口 */
            top: 0;
            left: 0;
            z-index: 0; /* 放置在底层 */
            pointer-events: auto; /* 确保Canvas默认可以接收鼠标事件 */
        }
        #controls-panel {
            position: absolute; /* Stacked above canvas */
            top: 0;
            right: -320px; /* Hidden by default, adjusted width */
            width: 320px; /* Control panel width, more compact */
            max-width: 90vw; /* Adapt to small screens */
            height: 100vh;
            background-color: #2a2a2a; /* Darker panel background */
            overflow-y: auto; /* Allow scrolling */
            padding: 0.8rem; /* Reduced padding */
            z-index: 1; /* Place above canvas */
            box-shadow: -8px 0 20px rgba(0, 0, 0, 0.4); /* More noticeable soft shadow */
            border-left: 1px solid #3a3a3a; /* Softer left border */
            color: #E0E0E0; /* Text color */
            transition: right 0.4s ease-out; /* Panel show/hide transition */
            font-size: 0.875rem; /* Base font size for panel, smaller */
            pointer-events: auto; /* Ensure panel receives its own events */
        }
        #controls-panel.active {
            right: 0; /* Show */
        }

        /* Hide all login-related UI elements */
        #login-overlay, #admin-login-button-container {
            display: none !important;
        }

        /* General input field styles */
        input[type="number"], input[type="text"], input[type="password"], select {
            background-color: #383838; /* Input background, darker */
            border: 1px solid #4a4a4a; /* Input border */
            color: #E0E0E0; /* Input text color */
            border-radius: 4px; /* Slightly more rounded */
            padding: 0.4rem 0.6rem; /* Reduced padding */
            height: 2rem; /* Fixed height, smaller */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-sizing: border-box; /* Ensure padding doesn't increase width */
            font-size: 0.875rem; /* Smaller font inside inputs */
        }
        input[type="number"]:focus, input[type="text"]:focus, input[type="password"]:focus, select:focus {
            border-color: #4a90e2; /* Softer blue focus border */
            outline: none;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.4); /* Wider, softer blue glow */
        }
        input[type="color"] {
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 2px;
            cursor: pointer;
            background-color: #383838;
            box-sizing: border-box;
            transition: border-color 0.2s ease-in-out;
            height: 2rem; /* Fixed height */
        }
        input[type="color"]:hover {
            border-color: #6a6a6a;
        }
        
        /* Range Slider Styling (kept for global properties) */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px; /* Thinner track */
            background: #4a4a4a; /* Darker track */
            outline: none;
            opacity: 0.8;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 2px; /* Rounded track */
            margin-top: 0.2rem; /* Spacing */
            margin-bottom: 0.2rem; /* Spacing */
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px; /* Smaller thumb */
            height: 16px; /* Smaller thumb */
            background: #4a90e2; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%; /* Circular thumb */
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.4); /* Glow effect */
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4a90e2;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.4);
        }

        /* Group for Slider and Number Input */
        .slider-number-group {
            display: flex;
            align-items: center;
            gap: 0.4rem; /* Reduced spacing */
        }
        .slider-number-group input[type="range"] {
            flex-grow: 1; /* Slider takes most space */
            margin-top: 0; /* Remove top margin from default slider style */
            margin-bottom: 0;
        }
        .slider-number-group input[type="number"] {
            width: 60px; /* Fixed width */
            text-align: right;
            padding-right: 0.3rem;
            padding-left: 0.3rem;
            height: 2rem; /* Match other inputs */
        }
        
        /* Collapsible header styling */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.4rem; /* Reduced padding */
            font-weight: 600;
            color: #E0E0E0;
            border-bottom: 1px solid #3a3a3a; /* Softer divider */
            margin-bottom: 0.6rem; /* Reduced bottom margin */
            transition: color 0.2s ease-in-out;
            font-size: 0.95rem; /* Smaller section title font */
        }
        .collapsible-header:hover {
            color: #4a90e2; /* Soft blue on hover */
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out; 
        }
        .collapsible-content.active {
            margin-bottom: 0.6rem; /* Reduced bottom margin */
        }
        .rotate-90 {
            transform: rotate(90deg);
        }
        .transition-transform {
            transition: transform 0.3s ease-in-out; 
        }

        /* Checkbox styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 36px; /* Slightly narrower */
            height: 20px; /* Slightly shorter */
            margin-left: 6px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555555; /* Gray inactive */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 18px; /* More rounded */
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px; /* Slightly larger */
            width: 16px; /* Slightly larger */
            left: 2px;
            bottom: 2px;
            background-color: #CCCCCC; /* Light gray thumb */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #4a90e2; /* Blue active */
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(16px); /* Adjust thumb movement distance */
            -ms-transform: translateX(16px);
            transform: translateX(16px);
            background-color: #FFFFFF; /* White thumb */
        }

        /* Buttons */
        .btn-primary {
            @apply py-1.5 px-3 bg-blue-600 text-white font-medium rounded-md shadow-sm transition duration-300; /* More compact */
            @apply hover:bg-blue-700 hover:shadow-md transform hover:scale-102;
            @apply focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50;
            font-size: 0.8rem; /* Smaller button text */
        }
        .btn-red {
            @apply py-1.5 px-3 bg-red-600 text-white font-medium rounded-md shadow-sm transition duration-300; /* More compact */
            @apply hover:bg-red-700 transform hover:scale-102;
            @apply focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50;
            font-size: 0.8rem;
        }
        .btn-indigo {
            @apply py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md transition duration-300; /* Slightly larger as main button */
            @apply hover:bg-indigo-700 hover:shadow-lg transform hover:scale-105;
            @apply focus:outline-none focus:ring-3 focus:ring-indigo-500 focus:ring-opacity-50;
            font-size: 0.9rem; /* Slightly smaller for main button */
        }


        /* Loading Spinner */
        .loader {
            border: 3px solid rgba(255, 255, 255, 0.3); /* Light grey */
            border-top: 3px solid #fff; /* White */
            border-radius: 50%;
            width: 20px; /* Smaller loader */
            height: 20px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Admin Login Button on main canvas */
        #admin-login-button-container {
            position: absolute;
            top: 1rem; /* Adjust position */
            right: 1rem; /* Adjust position */
            z-index: 50; /* Lower than control panel, higher than canvas */
            display: flex;
            gap: 0.8rem; /* Adjust gap */
        }

        /* Top Panel Styles */
        #top-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent dark background */
            color: #E0E0E0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            box-sizing: border-box;
            z-index: 10; /* Above canvas, below controls panel */
            font-size: 0.9rem;
            border-bottom-left-radius: 8px; /* Rounded corners for the top panel */
            border-bottom-right-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #top-panel button {
            @apply py-1 px-2 bg-gray-700 text-white font-medium rounded-md shadow-sm transition duration-300;
            @apply hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50;
            font-size: 0.75rem; /* Smaller buttons in top panel */
        }
    </style>
</head>
<body class="p-0">
    <canvas id="webgl-canvas"></canvas>

    <!-- Top operation panel -->
    <div id="top-panel" class="px-4 py-2">
        <div>模型数量: <span id="model-count">0</span></div>
        <div class="flex gap-2">
            <button id="toggle-controls" class="btn-primary">配置面板</button>
            <button id="reset-view" class="btn-primary">重置视图</button>
            <button id="set-default-view" class="btn-primary">设置默认视图</button>
        </div>
    </div>

    <!-- Hide all login-related UI elements -->
    <div id="admin-login-button-container" style="display: none;"></div>
    <div id="login-overlay" style="display: none;"></div>


    <div id="controls-panel" class="">
        <div class="flex justify-between items-center mb-3"> <!-- Reduced bottom margin -->
            <h1 class="text-lg font-extrabold text-gray-100">🎨 场景配置工具</h1> <!-- Reduced font size -->
        </div>

        <!-- Admin controls content always visible if panel is active -->
        <div id="admin-controls-content">
            <!-- Global Scene Settings Section -->
            <div class="bg-gray-800 p-3 rounded-md shadow-inner mb-2 border border-gray-700">
                <div class="collapsible-header" data-target="global-scene-settings-content">
                    <h2 class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2 text-yellow-400" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
                        </svg>
                        全局场景设置
                    </h2>
                    <svg class="h-4 w-4 text-gray-400 transition-transform arrow-icon" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div id="global-scene-settings-content" class="collapsible-content">
                    <!-- Camera Settings -->
                    <div class="mb-3">
                        <h3 class="text-sm font-semibold text-gray-200 mb-1">相机</h3>
                        <div class="grid grid-cols-1 gap-2">
                            <div>
                                <label for="camera-fov-num" class="block text-xs font-medium text-gray-300 mb-0.5">视野 (FOV)</label>
                                <div class="slider-number-group">
                                    <input type="range" id="camera-fov-range" value="50" min="1" max="179" step="1">
                                    <input type="number" id="camera-fov-num" value="50" min="1" max="179" step="1" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-300 mb-0.5">位置 (X, Y, Z)</label>
                                <div class="grid grid-cols-1 gap-1.5">
                                    <div class="slider-number-group">
                                        <input type="range" id="camera-pos-x-range" value="0" min="-20" max="20" step="0.1">
                                        <input type="number" id="camera-pos-x-num" value="0" step="0.1" class="rounded-sm">
                                    </div>
                                    <div class="slider-number-group">
                                        <input type="range" id="camera-pos-y-range" value="0.8" min="-20" max="20" step="0.1">
                                        <input type="number" id="camera-pos-y-num" value="0.8" step="0.1" class="rounded-sm">
                                    </div>
                                    <div class="slider-number-group">
                                        <input type="range" id="camera-pos-z-range" value="8" min="-20" max="20" step="0.1">
                                        <input type="number" id="camera-pos-z-num" value="8" step="0.1" class="rounded-sm">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Fog Settings -->
                    <div class="border-t border-gray-700 pt-3 mt-3 mb-3">
                        <h3 class="text-sm font-semibold text-gray-200 mb-1 flex items-center">
                            <span class="mr-2">雾效</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="fog-enabled">
                                <span class="slider"></span>
                            </label>
                        </h3>
                        <div id="fog-controls" class="grid grid-cols-1 gap-2">
                            <div>
                                <label for="fog-color" class="block text-xs font-medium text-gray-300 mb-0.5">雾颜色</label>
                                <input type="color" id="fog-color" value="#aaaaaa" class="w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                            </div>
                             <div>
                                <label for="fog-opacity-num" class="block text-xs font-medium text-gray-300 mb-0.5">雾效密度 (0.0-1.0)</label>
                                <div class="slider-number-group">
                                    <input type="range" id="fog-opacity-range" value="1.0" min="0.0" max="1.0" step="0.01">
                                    <input type="number" id="fog-opacity-num" value="1.0" min="0.0" max="1.0" step="0.01" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="fog-near-num" class="block text-xs font-medium text-gray-300 mb-0.5">雾起始距离</label>
                                <div class="slider-number-group">
                                    <input type="range" id="fog-near-range" value="10" min="0" max="100" step="1">
                                    <input type="number" id="fog-near-num" value="10" min="0" max="100" step="1" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="fog-far-num" class="block text-xs font-medium text-gray-300 mb-0.5">雾结束距离</label>
                                <div class="slider-number-group">
                                    <input type="range" id="fog-far-range" value="30" min="0" max="200" step="1">
                                    <input type="number" id="fog-far-num" value="30" min="0" max="200" step="1" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Scene Background & Environment -->
                    <div class="border-t border-gray-700 pt-3 mt-3 mb-3">
                        <h3 class="text-sm font-semibold text-gray-200 mb-1">背景与环境</h3>
                        <div class="grid grid-cols-1 gap-2">
                            <div>
                                <label for="background-mode" class="block text-xs font-medium text-gray-300 mb-0.5">背景模式</label>
                                <select id="background-mode" class="w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-xs">
                                    <option value="gradient">渐变色</option>
                                    <option value="color">纯色</option>
                                    <option value="hdr">HDR环境图</option>
                                </select>
                            </div>
                            <div id="solid-color-controls" class="hidden">
                                <label for="scene-background-color" class="block text-xs font-medium text-gray-300 mb-0.5">背景纯色</label>
                                <input type="color" id="scene-background-color" value="#111111" class="w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                            </div>
                            <div id="gradient-color-controls">
                                <div>
                                    <label for="gradient-color1" class="block text-xs font-medium text-gray-300 mb-0.5">渐变色 1</label>
                                    <input type="color" id="gradient-color1" value="#ADD8E6" class="w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                                </div>
                                <div>
                                    <label for="gradient-color2" class="block text-xs font-medium text-gray-300 mb-0.5">渐变色 2</label>
                                    <input type="color" id="gradient-color2" value="#FFFFFF" class="w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                                </div>
                            </div>
                            <div id="hdr-controls" class="hidden">
                                <div>
                                    <label for="hdr-upload" class="block text-xs font-medium text-gray-300 mb-0.5">上传 HDR 环境图 (.hdr)</label>
                                    <input type="file" id="hdr-upload" accept=".hdr" class="w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-xs">
                                    <p class="text-xs text-gray-400 mt-1">始终用于打光。</p>
                                    <div id="hdr-loader-status" class="flex items-center gap-2 mt-2 hidden text-orange-300 text-xs">
                                        <div class="loader"></div>
                                        <span>加载 HDR...</span>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between mt-2">
                                    <label for="display-hdr-as-background" class="text-xs font-medium text-gray-300">显示 HDR 作为背景</label>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="display-hdr-as-background">
                                        <span class="slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Lighting Settings -->
                    <div class="border-t border-gray-700 pt-3 mt-3 mb-3">
                        <h3 class="text-sm font-semibold text-gray-200 mb-1">灯光</h3>
                        <div class="grid grid-cols-1 gap-2">
                            <div>
                                <label for="light-ambient-intensity-num" class="block text-xs font-medium text-gray-300 mb-0.5">环境光强度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="light-ambient-intensity-range" value="1.1" step="0.1" min="0" max="5">
                                    <input type="number" id="light-ambient-intensity-num" value="1.1" step="0.1" min="0" max="5" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="ambient-light-color" class="block text-xs font-medium text-gray-300 mb-0.5">环境光颜色</label>
                                <input type="color" id="ambient-light-color" value="#ffffff" class="w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                            </div>
                            <div>
                                <label for="light-directional-intensity-num" class="block text-xs font-medium text-gray-300 mb-0.5">方向光强度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="light-directional-intensity-range" value="2.5" step="0.1" min="0" max="5">
                                    <input type="number" id="light-directional-intensity-num" value="2.5" step="0.1" min="0" max="5" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="directional-light-color" class="block text-xs font-medium text-gray-300 mb-0.5">方向光颜色</label>
                                <input type="color" id="directional-light-color" value="#ffffff" class="w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-300 mb-0.5">方向光位置 (X, Y, Z)</label>
                                <div class="grid grid-cols-1 gap-1.5">
                                    <div class="slider-number-group">
                                        <input type="range" id="light-dir-pos-x-range" value="5" min="-20" max="20" step="0.1">
                                        <input type="number" id="light-dir-pos-x-num" value="5" step="0.1" class="rounded-sm">
                                    </div>
                                    <div class="slider-number-group">
                                        <input type="range" id="light-dir-pos-y-range" value="10" min="-20" max="20" step="0.1">
                                        <input type="number" id="light-dir-pos-y-num" value="10" step="0.1" class="rounded-sm">
                                    </div>
                                    <div class="slider-number-group">
                                        <input type="range" id="light-dir-pos-z-range" value="7.5" min="-20" max="20" step="0.1">
                                        <input type="number" id="light-dir-pos-z-num" value="7.5" step="0.1" class="rounded-sm">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Ambient Occlusion (AO) -->
                    <div class="border-t border-gray-700 pt-3 mt-3">
                        <h3 class="text-sm font-semibold text-gray-200 mb-1 flex items-center">
                            <span class="mr-2">环境光遮蔽 (AO)</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="ssao-enabled">
                                <span class="slider"></span>
                            </label>
                        </h3>
                        <div id="ssao-controls" class="grid grid-cols-1 gap-2">
                            <div>
                                <label for="ssao-radius-num" class="block text-xs font-medium text-gray-300 mb-0.5">半径</label>
                                <div class="slider-number-group">
                                    <input type="range" id="ssao-radius-range" value="2" min="0.1" max="10" step="0.1">
                                    <input type="number" id="ssao-radius-num" value="2" min="0.1" max="10" step="0.1" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="ssao-intensity-num" class="block text-xs font-medium text-gray-300 mb-0.5">强度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="ssao-intensity-range" value="1" min="0.1" max="5" step="0.1">
                                    <input type="number" id="ssao-intensity-num" value="1" min="0.1" max="5" step="0.1" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="ssao-bias-num" class="block text-xs font-medium text-gray-300 mb-0.5">偏移</label>
                                <div class="slider-number-group">
                                    <input type="range" id="ssao-bias-range" value="0.001" min="0.0001" max="0.1" step="0.0001">
                                    <input type="number" id="ssao-bias-num" value="0.001" min="0.0001" max="0.1" step="0.0001" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3D Models Section -->
            <div class="bg-gray-800 p-3 rounded-md shadow-inner mb-2 border border-gray-700">
                <div class="collapsible-header" data-target="models-settings-content">
                    <h2 class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2 text-green-400" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 3L1 9l11 6 11-6-11-6zm0 11.23L5.47 11.02 12 7.77l6.53 3.25L12 14.23zM5.47 16.02L12 12.77l6.53 3.25L12 19.23 5.47 16.02z"/>
                        </svg>
                        3D 模型
                    </h2>
                    <svg class="h-4 w-4 text-gray-400 transition-transform arrow-icon" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div id="models-settings-content" class="collapsible-content">
                    <div id="model-list" class="space-y-3">
                        <!-- Model configuration inputs will be dynamically added here -->
                        <p class="text-gray-400 text-sm italic text-center py-4">点击下方按钮添加模型</p>
                    </div>
                    <div class="flex flex-col space-y-2 mt-3">
                        <button id="upload-model-btn" class="btn-primary flex items-center justify-center text-sm w-full">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1.5" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
                            </svg>
                            上传 GLTF/GLB 模型
                        </button>
                        <button id="add-primitive-model-btn" class="btn-primary flex items-center justify-center text-sm w-full">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1.5" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
                            </svg>
                            添加原始模型 (球体/立方体/圆环/平面)
                        </button>
                        <button id="clear-all-models-btn" class="btn-red flex items-center justify-center text-sm w-full">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1.5" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                            </svg>
                            清除所有模型
                        </button>
                    </div>
                </div>
            </div>

            <!-- Interactive Elements Section -->
            <div class="bg-gray-800 p-3 rounded-md shadow-inner mb-2 border border-gray-700">
                <div class="collapsible-header" data-target="mouse-interaction-settings-content">
                    <h2 class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2 text-cyan-400" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 20H4c-1.103 0-2-.897-2-2V4c0-1.103.897-2 2-2h16c1.103 0 2 .897 2 2v8h-2V4h-16v14h6v2zm12-3h-4v-4h4v4zm0 2h-4v-4h4v4zm-2.5 1h-1.5v-1.5h1.5V19zM15 11c-1.654 0-3 1.346-3 3s1.346 3 3 3 3-1.346 3-3-1.346-3-3-3zm0 4c-.551 0-1-.449-1-1s.449-1 1-1 1 .449 1 1-.449 1-1 1z"/>
                        </svg>
                        互动元素 (悬停/点击)
                    </h2>
                    <svg class="h-4 w-4 text-gray-400 transition-transform arrow-icon" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div id="mouse-interaction-settings-content" class="collapsible-content">
                    <div class="grid grid-cols-1 gap-2">
                        <div>
                            <label for="hover-scale-factor-num" class="block text-xs font-medium text-gray-300 mb-0.5">悬停缩放因子</label>
                            <div class="slider-number-group">
                                <input type="range" id="hover-scale-factor-range" value="1.3" min="1.0" max="1.5" step="0.01">
                                <input type="number" id="hover-scale-factor-num" value="1.3" min="1.0" max="1.5" step="0.01" class="rounded-sm">
                            </div>
                        </div>
                        <div>
                            <label for="hover-duration-num" class="block text-xs font-medium text-gray-300 mb-0.5">动画持续时间 (秒)</label>
                            <div class="slider-number-group">
                                <input type="range" id="hover-duration-range" value="0.2" min="0.1" max="1.0" step="0.05">
                                <input type="number" id="hover-duration-num" value="0.2" min="0.1" max="1.0" step="0.05" class="rounded-sm">
                            </div>
                        </div>
                        <div>
                            <label for="hover-emissive-intensity-num" class="block text-xs font-medium text-gray-300 mb-0.5">发光强度</label>
                            <div class="slider-number-group">
                                <input type="range" id="hover-emissive-intensity-range" value="0.35" min="0.0" max="1.0" step="0.01">
                                <input type="number" id="hover-emissive-intensity-num" value="0.35" min="0.0" max="1.0" step="0.01" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>

            <!-- Post-processing Filters Section -->
            <div class="bg-gray-800 p-3 rounded-md shadow-inner mb-2 border border-gray-700">
                <div class="collapsible-header" data-target="filter-settings-content">
                    <h2 class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2 text-orange-400" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M10 16.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5-1.5.67-1.5 1.5zm6-5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5-1.5.67-1.5 1.5zm-3-8C7.5 3.5 4 7 4 11.5c0 3.79 2.91 6.84 6.75 7.42V21h.5v-2.08c3.84-.58 6.75-3.63 6.75-7.42C18 7 14.5 3.5 11 3.5z"/>
                        </svg>
                        后期处理滤镜
                    </h2>
                    <svg class="h-4 w-4 text-gray-400 transition-transform arrow-icon" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div id="filter-settings-content" class="collapsible-content">
                    <!-- Fisheye Effect -->
                    <div class="mb-2 p-2 bg-gray-900 rounded-md border border-gray-700">
                        <div class="filter-header-wrapper flex items-center justify-between mb-1">
                            <label for="filter-fisheye-enabled" class="text-sm font-medium text-gray-200">鱼眼效果</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="filter-fisheye-enabled" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="fisheye-controls" class="grid grid-cols-1 gap-1.5">
                            <div>
                                <label for="filter-fisheye-strength-num" class="block text-xs font-medium text-gray-300 mb-0.5">鱼眼强度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-fisheye-strength-range" value="0.5" step="0.05" min="0" max="1">
                                    <input type="number" id="filter-fisheye-strength-num" value="0.5" step="0.05" min="0" max="1" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Chromatic Aberration -->
                    <div class="mb-2 p-2 bg-gray-900 rounded-md border border-gray-700">
                        <div class="filter-header-wrapper flex items-center justify-between mb-1">
                            <label for="filter-aberration-enabled" class="text-sm font-medium text-gray-200">色差</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="filter-aberration-enabled" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="aberration-controls" class="grid grid-cols-1 gap-1.5">
                            <div>
                                <label for="filter-aberration-num" class="block text-xs font-medium text-gray-300 mb-0.5">色差量</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-aberration-range" value="1.0" step="0.1" min="0" max="3">
                                    <input type="number" id="filter-aberration-num" value="1.0" step="0.1" min="0" max="3" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Pixelation -->
                    <div class="mb-2 p-2 bg-gray-900 rounded-md border border-gray-700">
                        <div class="filter-header-wrapper flex items-center justify-between mb-1">
                            <label for="filter-pixel-enabled" class="text-sm font-medium text-gray-200">像素化</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="filter-pixel-enabled" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="pixel-controls" class="grid grid-cols-1 gap-1.5">
                            <div>
                                <label for="filter-pixel-grid-size" class="block text-xs font-medium text-gray-300 mb-0.5">像素网格大小</label>
                                <select id="filter-pixel-grid-size" class="w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
                                    <option value="2">2x2</option>
                                    <option value="4">4x4</option>
                                    <option value="8">8x8 (默认)</option>
                                    <option value="16">16x16</option>
                                    <option value="32">32x32</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Bayer Dithering -->
                    <div class="mb-2 p-2 bg-gray-900 rounded-md border border-gray-700">
                        <div class="filter-header-wrapper flex items-center justify-between mb-1">
                            <label for="filter-dithering-enabled" class="text-sm font-medium text-gray-200">拜耳抖动</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="filter-dithering-enabled" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="dithering-controls" class="grid grid-cols-1 gap-1.5">
                            <div>
                                <label for="filter-dithering-num" class="block text-xs font-medium text-gray-300 mb-0.5">抖动强度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-dithering-range" value="1.0" step="0.05" min="0" max="2.0">
                                    <input type="number" id="filter-dithering-num" value="1.0" step="0.05" min="0" max="2.0" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-dithering-color-resolution" class="block text-xs font-medium text-gray-300 mb-0.5">抖动颜色分辨率</label>
                                <select id="filter-dithering-color-resolution" class="w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
                                    <option value="2.0">2 颜色 (1 bit)</option>
                                    <option value="4.0">4 颜色 (2 bit)</option>
                                    <option value="8.0">8 颜色 (3 bit)</option>
                                    <option value="16.0">16 颜色 (4 bit) (默认)</option>
                                    <option value="32.0">32 颜色 (5 bit)</option>
                                    <option value="64.0">64 颜色 (6 bit)</option>
                                    <option value="128.0">128 颜色 (7 bit)</option>
                                    <option value="256.0">256 颜色 (8 bit)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Bloom Effect -->
                    <div class="mb-2 p-2 bg-gray-900 rounded-md border border-gray-700">
                        <div class="filter-header-wrapper flex items-center justify-between mb-1">
                            <label for="filter-bloom-enabled" class="text-sm font-medium text-gray-200">辉光效果</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="filter-bloom-enabled" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="bloom-controls" class="grid grid-cols-1 gap-1.5">
                            <div>
                                <label for="filter-bloom-strength-num" class="block text-xs font-medium text-gray-300 mb-0.5">强度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-bloom-strength-range" value="0.8" step="0.1" min="0" max="5">
                                    <input type="number" id="filter-bloom-strength-num" value="0.8" step="0.1" min="0" max="5" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-bloom-radius-num" class="block text-xs font-medium text-gray-300 mb-0.5">半径</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-bloom-radius-range" value="0.5" step="0.1" min="0" max="5">
                                    <input type="number" id="filter-bloom-radius-num" value="0.5" step="0.1" min="0" max="5" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-bloom-threshold-num" class="block text-xs font-medium text-gray-300 mb-0.5">阈值</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-bloom-threshold-range" value="0.6" step="0.05" min="0" max="1">
                                    <input type="number" id="filter-bloom-threshold-num" value="0.6" step="0.05" min="0" max="1" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Color Grading -->
                    <div class="mb-2 p-2 bg-gray-900 rounded-md border border-gray-700">
                        <div class="filter-header-wrapper flex items-center justify-between mb-1">
                            <label for="filter-color-grading-enabled" class="text-sm font-medium text-gray-200">色彩分级</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="filter-color-grading-enabled" checked>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="color-grading-controls" class="grid grid-cols-1 gap-1.5">
                            <div>
                                <label for="filter-brightness-num" class="block text-xs font-medium text-gray-300 mb-0.5">亮度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-brightness-range" value="0.0" step="0.05" min="-1" max="1">
                                    <input type="number" id="filter-brightness-num" value="0.0" step="0.05" min="-1" max="1" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-contrast-num" class="block text-xs font-medium text-gray-300 mb-0.5">对比度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-contrast-range" value="1.0" step="0.05" min="0" max="3">
                                    <input type="number" id="filter-contrast-num" value="1.0" step="0.05" min="0" max="3" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-saturation-num" class="block text-xs font-medium text-gray-300 mb-0.5">饱和度</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-saturation-range" value="1.0" step="0.05" min="0" max="3">
                                    <input type="number" id="filter-saturation-num" value="1.0" step="0.05" min="0" max="3" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-hue-offset-num" class="block text-xs font-medium text-gray-300 mb-0.5">色相偏移 (弧度)</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-hue-offset-range" value="0.0" step="0.1" min="-3.14" max="3.14">
                                    <input type="number" id="filter-hue-offset-num" value="0.0" step="0.1" min="-3.14" max="3.14" class="rounded-sm">
                                </div>
                            </div>
                            <div>
                                <label for="filter-gamma-num" class="block text-xs font-medium text-gray-300 mb-0.5">伽马</label>
                                <div class="slider-number-group">
                                    <input type="range" id="filter-gamma-range" value="2.2" step="0.1" min="0.1" max="5">
                                    <input type="number" id="filter-gamma-num" value="2.2" step="0.1" min="0.1" max="5" class="rounded-sm">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Generate Button -->
            <button id="generate-config-btn" class="btn-indigo w-full flex items-center justify-center mt-4"> <!-- Adjusted top margin -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                生成并下载 config.json
            </button>

            <!-- Instructions Section -->
            <div class="bg-gray-900 p-3 rounded-md shadow-inner mt-3 text-xs text-gray-300 leading-tight border border-gray-800"> <!-- Reduced padding and top margin, tighter line height -->
                <h2 class="text-sm font-bold mb-1.5 text-gray-100">使用说明 🚀</h2> <!-- Reduced font size, reduced spacing -->
                <ol class="list-decimal list-inside space-y-1"> <!-- Reduced spacing -->
                    <li>在右侧面板调整参数；3D 场景实时更新。</li>
                    <li>每个滤镜旁边都有开关，可启用/禁用。</li>
                    <li><span class="font-semibold text-blue-400">点击场景中的模型以选中它，然后按 <kbd>W</kbd> (移动), <kbd>E</kbd> (旋转), <kbd>R</kbd> (缩放) 键切换操作模式并进行可视化操作。</span></li>
                    <li>当面板关闭时，点击模型将打开其关联的 URL；当面板打开时，点击模型仅用于选中和操作。</li>
                    <li>要保存当前配置，点击底部的 "<span class="font-semibold text-blue-400">生成并下载 config.json</span>" 按钮。</li>
                    <li>您可以上传本地 GLTF/GLB 文件，但大型文件可能会影响性能。</li>
                    <li class="mt-2 font-bold text-yellow-300">管理员访问：按 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>S</kbd> 键切换此面板的可见性。</li> <!-- Reduced top margin -->
                </ol>
            </div>
        </div> <!-- End of admin-controls-content -->
    </div>

    <!-- Three.js and related libraries scripts -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { SSAARenderPass } from 'three/addons/postprocessing/SSAARenderPass.js'; // For SSAO

        // --- Core Variables ---
        let scene, camera, renderer, controls, composer, ambientLight, dirLight;
        let raycaster, mouse;
        const interactiveObjects = []; // Stores THREE.Mesh objects that are interactive
        let highlightedObject = null; // Object currently highlighted by hover
        let modelLoadStatusMap = new Map(); // Stores loading status for each model, key: modelId, value: boolean (true=loading)
        let gradientBackgroundPlane = null; // Reference to the gradient background plane mesh
        let ssaoPass; // Declare SSAO pass

        // Raw content from the uploaded config (3).json
        const uploadedConfigRaw = {
            "camera": {
                "fov": 50,
                "position": [
                    -0.2,
                    0.8,
                    7.2
                ]
            },
            "fog": {
                "enabled": true,
                "color": "#4268ff",
                "near": 10,
                "far": 30
            },
            "lighting": {
                "ambientIntensity": 1.1,
                "ambientColor": "#4400ff",
                "directionalIntensity": 2.5,
                "directionalColor": "#ffffff",
                "directionalPosition": [
                    5,
                    10,
                    7.5
                ]
            },
            "ambientOcclusion": {
                "enabled": true,
                "radius": 3.6,
                "intensity": 4.3,
                "bias": 0.0103
            },
            "models": [
                {
                    "id": "model_0",
                    "modelUrl": "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb",
                    "actionUrl": "https://threejs.org/",
                    "position": [
                        -3.5,
                        -0.5,
                        0
                    ],
                    "scale": [
                        1,
                        1,
                        1
                    ],
                    "type": "GLTF",
                    "materialType": "Standard",
                    "receiveShadow": true,
                    "castShadow": true,
                    "rotation": [
                        0,
                        0,
                        0
                    ]
                },
                {
                    "id": "model_1",
                    "modelUrl": "https://threejs.org/examples/models/gltf/Flamingo.glb",
                    "actionUrl": "https://www.google.com/",
                    "position": [
                        0,
                        0,
                        0
                    ],
                    "scale": [
                        0.03,
                        0.03,
                        0.03
                    ],
                    "type": "GLTF",
                    "materialType": "Standard",
                    "receiveShadow": true,
                    "castShadow": true,
                    "rotation": [
                        0,
                        0,
                        0
                    ]
                },
                {
                    "id": "model_ground",
                    "type": "Plane",
                    "materialType": "Standard",
                    "position": [
                        0,
                        -0.01,
                        0
                    ],
                    "scale": [
                        30,
                        30,
                        1
                    ],
                    "rotation": [
                        -1.5707963267948966,
                        0,
                        0
                    ],
                    "color": "#ffffff",
                    "modelUrl": "",
                    "actionUrl": "",
                    "receiveShadow": true,
                    "castShadow": true
                }
            ],
            "filter": {
                "fisheyeStrength": 0.5,
                "fisheyeEnabled": false,
                "aberrationAmount": 1,
                "ditheringMultiply": 2,
                "ditheringColorResolution": 64,
                "pixelGridSize": 4,
                "brightness": 0,
                "contrast": 1,
                "saturation": 1,
                "hueOffset": 0,
                "gamma": 1,
                "bloomStrength": 1.3,
                "bloomRadius": 0.5,
                "bloomThreshold": 1,
                "aberrationEnabled": true,
                "ditheringEnabled": true,
                "pixelEnabled": true,
                "bloomEnabled": true,
                "outlineEnabled": false,
                "colorGradingEnabled": false
            },
            "interaction": {
                "hoverScaleFactor": 1.1,
                "hoverDuration": 0.2,
                "hoverEmissiveIntensity": 0.35
            },
            "background": {
                "mode": "color",
                "color": "#0008ff",
                "gradientColor1": "#add8e6",
                "gradientColor2": "#ffffff",
                "hdrUrl": "",
                "displayHdrAsBackground": false
            }
        };

        // Define defaultAppConfig based on the uploaded config, and add new properties
        const defaultAppConfig = JSON.parse(JSON.stringify(uploadedConfigRaw));

        // Add new properties with their default values if they don't exist in the uploaded config
        if (typeof defaultAppConfig.fog.fogOpacity === 'undefined') {
            defaultAppConfig.fog.fogOpacity = 1.0;
        }

        // Add cameraDefault to defaultAppConfig
        defaultAppConfig.cameraDefault = JSON.parse(JSON.stringify(defaultAppConfig.camera));

        // Initialize appConfig from the new defaultAppConfig
        let appConfig = JSON.parse(JSON.stringify(defaultAppConfig));

        let sceneInitialized = false;
        let bloomPass;
        let customShaderPass;
        let hoverAnimation = null;
        let isPanelVisible = false; // Set to false to make the panel hidden by default
        let nextModelId = 2; // Start from 2 if default models are present (0 and 1)

        let transformControls = null;
        let selectedObject = null; // Currently selected object for TransformControls


        // Debounce function to limit how often a function is called
        let debounceTimer;
        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        }
        const debouncedUpdateConfigFromUI = debounce(updateConfigFromUI, 100);

        // --- Custom Shader for Gradient Background ---
        const GradientBackgroundShader = {
            uniforms: {
                color1: { value: new THREE.Color("#ADD8E6") },
                color2: { value: new THREE.Color("#FFFFFF") }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                varying vec2 vUv;
                void main() {
                    // Mix colors based on Y-coordinate (vUv.y) for vertical gradient
                    gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
                }
            `
        };

        // --- Custom Shader for Effects ---
        const CustomShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'bayerTexture': { value: createBayerTexture() },
                'resolution': { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                // Filter parameters
                'fisheyeStrength': { value: 0.0 },
                'aberrationAmount': { value: 0 },
                'ditheringMultiply': { value: 0 },
                'ditheringColorResolution': { value: 256.0 },
                'pixelGridSize': { value: 8.0 },
                'brightness': { value: 0.0 },
                'contrast': { value: 1.0 },
                'saturation': { value: 1.0 },
                'hueOffset': { value: 0.0 },
                'gamma': { value: 2.2 },
                // Filter enabled/disabled flags
                'fisheyeEnabled': { value: 0 },
                'aberrationEnabled': { value: 1 },
                'ditheringEnabled': { value: 1 },
                'pixelEnabled': { value: 1 },
                'outlineEnabled': { value: 0 },
                'colorGradingEnabled': { value: 1 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform sampler2D tDiffuse;
                uniform sampler2D bayerTexture;
                uniform vec2 resolution;
                uniform float fisheyeStrength;
                uniform float aberrationAmount;
                uniform float ditheringMultiply;
                uniform float ditheringColorResolution;
                uniform float pixelGridSize;
                uniform float brightness;
                uniform float contrast;
                uniform float saturation;
                uniform float hueOffset;
                uniform float gamma;
                // Enable/disable flags
                uniform int fisheyeEnabled;
                uniform int aberrationEnabled;
                uniform int ditheringEnabled;
                uniform int pixelEnabled;
                uniform int outlineEnabled;
                uniform int colorGradingEnabled;

                vec3 applyHueShift(vec3 color, float hue) {
                    float C = dot(color, vec3(0.2126, 0.7152, 0.0722));
                    float cosHue = cos(hue);
                    float sinHue = sin(hue);
                    mat3 hueRotationMatrix = mat3(
                        vec3(0.299 + 0.701 * cosHue + 0.168 * sinHue, 0.587 - 0.587 * cosHue + 0.330 * sinHue, 0.114 - 0.114 * cosHue - 0.497 * sinHue),
                        vec3(0.299 - 0.299 * cosHue - 0.168 * sinHue, 0.587 + 0.413 * cosHue - 0.330 * sinHue, 0.114 - 0.114 * cosHue + 0.497 * sinHue),
                        vec3(0.299 - 0.299 * cosHue + 1.250 * sinHue, 0.587 - 1.050 * sinHue, 0.114 + 0.886 * cosHue - 0.203 * sinHue)
                    );
                    return color * hueRotationMatrix;
                }

                void main() {
                    vec2 currentUv = vUv;

                    // 1. Fisheye Effect (applied first to UV)
                    if (bool(fisheyeEnabled)) { // Fixed typo: fisheeyeEnabled -> fisheyeEnabled
                        vec2 center = vec2(0.5, 0.5);
                        vec2 vecToCenter = currentUv - center;
                        float dist = length(vecToCenter);
                        // Apply distortion based on strength
                        float newDist = mix(dist, sqrt(dist), fisheyeStrength);
                        currentUv = center + normalize(vecToCenter) * newDist;
                    }
                    
                    vec3 finalColor = texture2D(tDiffuse, currentUv).rgb;

                    // 2. Pixelation Effect (applied to original color or already fisheyed)
                    vec2 pixelatedUv = currentUv;
                    if (bool(pixelEnabled)) {
                        vec2 pixelSize = 1.0 / (resolution / pixelGridSize);
                        pixelatedUv = floor(currentUv / pixelSize) * pixelSize; 
                        finalColor = texture2D(tDiffuse, pixelatedUv).rgb; 
                    }

                    // 3. Chromatic Aberration (applied to pixelated or original color)
                    if (bool(aberrationEnabled)) {
                        vec2 uv_offset_r = vec2(aberrationAmount / resolution.x, 0.0);
                        vec2 uv_offset_b = vec2(-aberrationAmount / resolution.x, 0.0);

                        vec3 color_r = texture2D(tDiffuse, pixelatedUv + uv_offset_r).rgb;
                        vec3 color_g = texture2D(tDiffuse, pixelatedUv).rgb;
                        vec3 color_b = texture2D(tDiffuse, pixelatedUv + uv_offset_b).rgb;
                        finalColor = vec3(color_r.r, color_g.g, color_b.b);
                    }


                    // 4. Bayer Ordered Dithering with color quantization
                    if (bool(ditheringEnabled)) {
                        float bayerValue = texture2D(bayerTexture, gl_FragCoord.xy / (pixelGridSize * 8.0)).r;
                        
                        // Quantize the color to a fixed number of steps per channel
                        float levels = ditheringColorResolution;
                        vec3 quantizedColor = floor(finalColor * levels);

                        // Add dither value and re-normalize to 0-1
                        // ditheringMultiply scales the 'push' of bayerValue towards the next color level
                        finalColor = (quantizedColor + bayerValue * ditheringMultiply) / levels;
                        finalColor = clamp(finalColor, 0.0, 1.0);
                    }

                    // 5. Color Grading
                    if (bool(colorGradingEnabled)) {
                        finalColor += brightness;
                        finalColor = (finalColor - 0.5) * contrast + 0.5;
                        vec3 luminanceVec = vec3(0.2126, 0.7152, 0.0722);
                        vec3 gray = vec3(dot(finalColor, luminanceVec));
                        finalColor = mix(gray, finalColor, saturation);
                        finalColor = applyHueShift(finalColor, hueOffset);
                        finalColor = pow(finalColor, vec3(1.0 / gamma));
                    }
                    
                    // Outline Effect is disabled (uniform outlineEnabled is 0)
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        };

        // --- Initialize Three.js Scene ---
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            // Background will be set in updateSceneParameters based on appConfig.background.mode

            // Camera setup
            camera = new THREE.PerspectiveCamera(appConfig.camera.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.fromArray(appConfig.camera.position);

            // Renderer setup
            const canvas = document.getElementById('webgl-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true; // Enable shadow maps
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

            // Lighting setup
            ambientLight = new THREE.AmbientLight(appConfig.lighting.ambientColor, appConfig.lighting.ambientIntensity);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(appConfig.lighting.directionalColor, appConfig.lighting.directionalIntensity);
            dirLight.position.fromArray(appConfig.lighting.directionalPosition);
            dirLight.castShadow = true; // Enable light to cast shadows
            // Shadow camera properties for better shadow quality
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -10;
            dirLight.shadow.camera.right = 10;
            dirLight.shadow.camera.top = 10;
            dirLight.shadow.camera.bottom = -10;
            scene.add(dirLight);

            // Orbit Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Initialize TransformControls with error handling
            try {
                transformControls = new TransformControls(camera, renderer.domElement);
                scene.add(transformControls);
                transformControls.visible = false; // Initially hidden

                transformControls.addEventListener('dragging-changed', function (event) {
                    controls.enabled = !event.value;
                });

                transformControls.addEventListener('objectChange', () => {
                    if (selectedObject && selectedObject.userData.configId) {
                        const modelConfig = appConfig.models.find(m => m.id === selectedObject.userData.configId);
                        if (modelConfig) {
                            modelConfig.position[0] = selectedObject.position.x;
                            modelConfig.position[1] = selectedObject.position.y;
                            modelConfig.position[2] = selectedObject.position.z;

                            modelConfig.scale[0] = selectedObject.scale.x;
                            modelConfig.scale[1] = selectedObject.scale.y;
                            modelConfig.scale[2] = selectedObject.scale.z;

                            modelConfig.rotation[0] = selectedObject.rotation.x; // Update rotation
                            modelConfig.rotation[1] = selectedObject.rotation.y;
                            modelConfig.rotation[2] = selectedObject.rotation.z;

                            // Update the originalScale property of the selected object directly
                            // This ensures that the hover effect uses the new user-defined scale as its base
                            selectedObject.userData.originalScale.copy(selectedObject.scale);

                            updateModelUIInputs(modelConfig.id, selectedObject.position, selectedObject.scale, selectedObject.rotation); // Pass rotation
                            // Note: No debouncedUpdateConfigFromUI here, as TransformControls directly updates object properties in scene
                            // and the UI inputs are updated, which will trigger the updateConfigFromUI via their own change listeners
                        }
                    }
                });
            } catch (e) {
                console.error("Failed to initialize TransformControls:", e);
                transformControls = null;
            }


            // Initialize models and setup post-processing
            syncModelsWithScene().then(() => {
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                // Interaction listeners are ALWAYS active, their behavior changes based on panel visibility.
                window.addEventListener('mousemove', onMouseMove, false);
                window.addEventListener('click', onMouseClick, false);
                window.addEventListener('resize', onWindowResize);
                setupPostProcessing(); // Setup post-processing *after* models are loaded
                animate();
                sceneInitialized = true;
                // No explicit updateInteractionListeners call needed here, as global listeners are always on.
            }).catch(error => console.error("Failed to initialize scene:", error));
        }

        // --- Load Initial Config ---
        async function loadInitialConfig() {
            if (appConfig.models && appConfig.models.length > 0) {
                // Filter out any undefined or null entries before mapping
                // Also ensures 'id' and other essential properties are present
                appConfig.models = appConfig.models.filter(m => 
                    m && typeof m.id === 'string' && 
                    Array.isArray(m.position) && Array.isArray(m.scale)
                );
                
                // Set initial nextModelId, excluding the fixed 'model_ground'
                const nonGroundModels = appConfig.models.filter(m => m.id !== 'model_ground');
                if (nonGroundModels.length > 0) {
                    const maxId = Math.max(...nonGroundModels.map(m => parseInt(m.id.replace('model_', '')) || 0));
                    nextModelId = maxId + 1;
                } else {
                    nextModelId = 0; // If only ground or no models, start from 0 for new non-ground models
                }

                // Ensure new URL properties exist for old configs
                appConfig.models.forEach(model => {
                    if (typeof model.modelUrl === 'undefined') {
                        model.modelUrl = model.url || ''; // Copy old 'url' if it exists
                        delete model.url; // Remove old 'url' property
                    }
                    if (typeof model.actionUrl === 'undefined') {
                        model.actionUrl = ''; // Default empty action URL
                    }
                    // Ensure receiveShadow and castShadow default
                    if (typeof model.receiveShadow === 'undefined') model.receiveShadow = true;
                    if (typeof model.castShadow === 'undefined') model.castShadow = true;
                    // Ensure rotation property exists
                    if (typeof model.rotation === 'undefined') {
                        model.rotation = [0, 0, 0];
                    }
                });

                // Ensure the ground model exists and is correct
                const groundModelIndex = appConfig.models.findIndex(m => m.id === 'model_ground');
                if (groundModelIndex === -1) {
                    appConfig.models.push(JSON.parse(JSON.stringify(defaultAppConfig.models.find(m => m.id === 'model_ground'))));
                    console.log("Added default ground model to config.");
                } else {
                    // Ensure ground model has correct shadow properties if it already exists
                    appConfig.models[groundModelIndex].receiveShadow = true;
                    appConfig.models[groundModelIndex].castShadow = false;
                    // Update ground position and rotation to default
                    const defaultGround = defaultAppConfig.models.find(m => m.id === 'model_ground');
                    appConfig.models[groundModelIndex].position = defaultGround.position;
                    appConfig.models[groundModelIndex].rotation = defaultGround.rotation;
                    appConfig.models[groundModelIndex].color = defaultGround.color;
                    // Remove texture-related properties from existing ground model
                    delete appConfig.models[groundModelIndex].textureUrl;
                    delete appConfig.models[groundModelIndex].textureRepeat;
                }
            } else {
                // If models array is empty, ensure it has the default ground and other two
                appConfig.models = JSON.parse(JSON.stringify(defaultAppConfig.models));
                nextModelId = 2; // Robot is 0, Flamingo is 1. Next is 2.
            }
        }

        // --- Update Scene Parameters ---
        async function updateSceneParameters() {
            console.log('updateSceneParameters: Updating scene parameters...');
            // Update Camera
            camera.fov = appConfig.camera.fov;
            camera.position.fromArray(appConfig.camera.position);
            camera.updateProjectionMatrix();

            // Update Fog
            if (appConfig.fog.enabled) {
                // Calculate effective far based on fogOpacity
                // Higher opacity (closer to 1) means smaller effective 'far' distance, making fog denser.
                // Lower opacity (closer to 0) means larger effective 'far' distance, making fog less dense.
                // Ensure no division by zero or very small numbers
                const effectiveFar = appConfig.fog.far / Math.max(0.001, appConfig.fog.fogOpacity);

                scene.fog = new THREE.Fog(
                    new THREE.Color(appConfig.fog.color),
                    appConfig.fog.near, // Keep near fixed as per standard Three.js Fog behavior
                    effectiveFar
                );
            } else {
                scene.fog = null;
            }


            // Update Scene Background
            if (gradientBackgroundPlane) {
                scene.remove(gradientBackgroundPlane);
                disposeObject(gradientBackgroundPlane); // Dispose old gradient plane
                gradientBackgroundPlane = null;
            }

            if (appConfig.background.mode === 'color') {
                scene.background = new THREE.Color(appConfig.background.color);
                scene.environment = null; // Clear HDR environment if not in HDR mode
            } else if (appConfig.background.mode === 'gradient') {
                scene.background = null; // Important: Clear direct background
                scene.environment = null; // Clear HDR environment if not in HDR mode

                const gradientMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color1: { value: new THREE.Color(appConfig.background.gradientColor1) },
                        color2: { value: new THREE.Color(appConfig.background.gradientColor2) }
                    },
                    vertexShader: GradientBackgroundShader.vertexShader,
                    fragmentShader: GradientBackgroundShader.fragmentShader,
                    side: THREE.BackSide, // Render on the inside of a large sphere
                    depthWrite: false, // Don't write to depth buffer to allow other objects to render in front
                    depthTest: false // Don't test depth
                });
                const sphereGeometry = new THREE.SphereGeometry(500, 32, 32); // Large sphere for background
                gradientBackgroundPlane = new THREE.Mesh(sphereGeometry, gradientMaterial);
                gradientBackgroundPlane.name = "gradientBackgroundSphere";
                scene.add(gradientBackgroundPlane);
            } else if (appConfig.background.mode === 'hdr') {
                if (appConfig.background.hdrUrl) {
                    const hdrLoaderStatus = document.getElementById('hdr-loader-status');
                    hdrLoaderStatus.classList.remove('hidden');
                    console.log('updateSceneParameters: Loading HDR environment from URL.');
                    try {
                        const hdrTexture = await new RGBELoader().loadAsync(appConfig.background.hdrUrl);
                        hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = hdrTexture; // Always apply for lighting

                        if (appConfig.background.displayHdrAsBackground) {
                            scene.background = hdrTexture; // Display as background
                        } else {
                            scene.background = null; // Clear background to allow for transparent sky or other effects
                        }
                        console.log('updateSceneParameters: HDR environment loaded successfully.');
                    } catch (error) {
                        console.error('updateSceneParameters: Error loading HDR texture:', error);
                        scene.environment = null; // Clear environment on error
                        scene.background = null; // Clear background on error
                        showMessageBox('HDR 加载失败: ' + error.message.substring(0, 100) + '...');
                    } finally {
                        hdrLoaderStatus.classList.add('hidden');
                    }
                } else {
                    scene.environment = null;
                    scene.background = null;
                }
            }

            // Update Lighting
            ambientLight.intensity = appConfig.lighting.ambientIntensity;
            ambientLight.color.set(appConfig.lighting.ambientColor);

            dirLight.intensity = appConfig.lighting.directionalIntensity;
            dirLight.color.set(appConfig.lighting.directionalColor);
            dirLight.position.fromArray(appConfig.lighting.directionalPosition);

            // Update Models (intelligent update instead of re-creating all)
            console.log('updateSceneParameters: Syncing models with scene.');
            await syncModelsWithScene();
            console.log('updateSceneParameters: Models synced.');

            // Update SSAO Pass
            if (ssaoPass) {
                ssaoPass.enabled = appConfig.ambientOcclusion.enabled;
                ssaoPass.radius = appConfig.ambientOcclusion.radius;
                ssaoPass.intensity = appConfig.ambientOcclusion.intensity;
                ssaoPass.bias = appConfig.ambientOcclusion.bias;
            }


            // Update Post-processing parameters
            // Temporarily disable post-processing to debug GLTF textures. Re-enable these lines one by one if textures display correctly.
            if (bloomPass) {
                bloomPass.strength = appConfig.filter.bloomEnabled ? appConfig.filter.bloomStrength : 0;
                bloomPass.radius = appConfig.filter.bloomRadius;
                bloomPass.threshold = appConfig.filter.bloomThreshold;
            }

            if (customShaderPass && customShaderPass.uniforms) {
                customShaderPass.uniforms['fisheyeStrength'].value = appConfig.filter.fisheyeStrength;
                customShaderPass.uniforms['fisheyeEnabled'].value = appConfig.filter.fisheyeEnabled ? 1 : 0;

                customShaderPass.uniforms['aberrationAmount'].value = appConfig.filter.aberrationAmount;
                customShaderPass.uniforms['ditheringMultiply'].value = appConfig.filter.ditheringMultiply;
                customShaderPass.uniforms['ditheringColorResolution'].value = appConfig.filter.ditheringColorResolution;
                customShaderPass.uniforms['pixelGridSize'].value = appConfig.filter.pixelGridSize;
                customShaderPass.uniforms['brightness'].value = appConfig.filter.brightness;
                customShaderPass.uniforms['contrast'].value = appConfig.filter.contrast;
                customShaderPass.uniforms['saturation'].value = appConfig.filter.saturation;
                customShaderPass.uniforms['hueOffset'].value = appConfig.filter.hueOffset;
                customShaderPass.uniforms['gamma'].value = appConfig.filter.gamma;
                // Update enabled flags
                customShaderPass.uniforms['aberrationEnabled'].value = appConfig.filter.aberrationEnabled ? 1 : 0;
                customShaderPass.uniforms['ditheringEnabled'].value = appConfig.filter.ditheringEnabled ? 1 : 0;
                customShaderPass.uniforms['pixelEnabled'].value = appConfig.filter.pixelEnabled ? 1 : 0;
                customShaderPass.uniforms['outlineEnabled'].value = appConfig.filter.outlineEnabled ? 1 : 0;
                customShaderPass.uniforms['colorGradingEnabled'].value = appConfig.filter.colorGradingEnabled ? 1 : 0;
            }
        }

        // --- Helper function to dispose Three.js objects ---
        function disposeObject(obj) {
            if (!obj) return;
            // Recursively traverse all children
            obj.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) {
                        child.geometry.dispose();
                        console.log(`Disposed geometry for mesh: ${child.name || child.uuid}`);
                    }
                    if (child.material) {
                        // If material is an array (multi-material), iterate through each material
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => {
                                if (material.map) material.map.dispose();
                                if (material.lightMap) material.lightMap.dispose();
                                if (material.bumpMap) material.bumpMap.dispose();
                                if (material.normalMap) material.normalMap.dispose();
                                if (material.specularMap) material.specularMap.dispose();
                                if (material.envMap) material.envMap.dispose();
                                if (material.gradientMap) material.gradientMap.dispose(); // Dispose gradient map
                                material.dispose();
                                console.log(`Disposed material for mesh: ${child.name || child.uuid}`);
                            });
                        } else {
                            // Single material
                            if (child.material.map) child.material.map.dispose();
                            if (child.material.lightMap) child.material.lightMap.dispose();
                            if (child.material.bumpMap) child.material.bumpMap.dispose();
                            if (child.material.normalMap) child.material.normalMap.dispose();
                            if (child.material.specularMap) child.material.specularMap.dispose();
                            if (child.material.envMap) child.material.envMap.dispose();
                            if (child.material.gradientMap) child.material.gradientMap.dispose(); // Dispose gradient map
                            child.material.dispose();
                            console.log(`Disposed material for mesh: ${child.name || child.uuid}`);
                        }
                    }
                }
            });

            // Remove object from its parent
            if (obj.parent) {
                obj.parent.remove(obj);
            }
        }

        /**
         * Updates the loading status UI for a specific model.
         * @param {string} modelId The ID of the model.
         * @param {boolean} isLoading Whether the model is currently loading.
         */
        function updateModelLoadingStatusUI(modelId, isLoading) {
            const loadingSpan = document.getElementById(`model-load-status-${modelId}`);
            if (loadingSpan) {
                if (isLoading) {
                    loadingSpan.classList.remove('hidden');
                    loadingSpan.innerHTML = '加载中... <span class="loader inline-block align-middle"></span>';
                } else {
                    loadingSpan.classList.add('hidden');
                    loadingSpan.innerHTML = ''; // Clear content when hidden
                }
            }
        }

        /**
         * Creates a custom toon gradient map for MeshToonMaterial.
         */
        function createCustomToonGradientMap(shadowColor, baseColor, highlightColor, shadowThreshold, highlightThreshold, smoothness) {
            const size = 256;
            const data = new Uint8Array(size * 4);

            const sColor = new THREE.Color(shadowColor);
            const bColor = new THREE.Color(baseColor);
            const hColor = new THREE.Color(highlightColor);

            for (let i = 0; i < size; i++) {
                const normalizedIntensity = i / (size - 1);
                let color = new THREE.Color();

                if (normalizedIntensity < shadowThreshold) {
                    color.copy(sColor);
                } else if (normalizedIntensity < highlightThreshold) {
                    color.copy(bColor);
                } else {
                    color.copy(hColor);
                }

                if (smoothness > 0) {
                    // Smooth transitions
                    if (normalizedIntensity >= shadowThreshold && normalizedIntensity < highlightThreshold) {
                        const blend = (normalizedIntensity - shadowThreshold) / (highlightThreshold - shadowThreshold);
                        color.lerpColors(sColor, bColor, blend);
                    } else if (normalizedIntensity >= highlightThreshold) {
                        const blend = (normalizedIntensity - highlightThreshold) / (1.0 - highlightThreshold);
                        color.lerpColors(bColor, hColor, blend);
                    }
                }
                data[i * 4] = Math.floor(color.r * 255);
                data[i * 4 + 1] = Math.floor(color.g * 255);
                data[i * 4 + 2] = Math.floor(color.b * 255);
                data[i * 4 + 3] = 255;
            }
            const texture = new THREE.DataTexture(data, size, 1, THREE.RGBAFormat);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        // --- Sync Models in appConfig with Scene ---
        async function syncModelsWithScene() {
            console.log("syncModelsWithScene: Starting model synchronization...");
            const loader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            // Configure DRACO decoder path (requires draco library downloaded into project)
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); // Changed to public CDN path
            loader.setDRACOLoader(dracoLoader);

            const modelsInSceneMap = new Map();

            // Populate map with existing models from scene based on their configId
            scene.children.forEach(obj => {
                if (obj.userData.configId) {
                    modelsInSceneMap.set(obj.userData.configId, obj);
                }
            });

            const newInteractiveObjects = [];
            
            // Create a filtered copy of the models array to iterate over
            const validModels = appConfig.models.filter(m => 
                m && typeof m.id === 'string' && 
                Array.isArray(m.position) && m.position.length === 3 &&
                Array.isArray(m.scale) && m.scale.length === 3 &&
                Array.isArray(m.rotation) && m.rotation.length === 3 // Ensure rotation property is present
            );
            console.log('syncModelsWithScene: Filtered valid models:', validModels);

            const loadPromises = validModels.map(async configData => {
                if (!configData || typeof configData.id !== 'string') {
                    console.warn('Skipping invalid configData entry in syncModelsWithScene map function:', configData);
                    return null;
                }

                let currentMesh = modelsInSceneMap.get(configData.id);
                let newMesh = null;
                const isGltfInConfig = configData.type === 'GLTF' && !!configData.modelUrl; // True if configData is GLTF and has a modelUrl

                let needsReplacement = false;
                if (currentMesh) {
                    // Check if GLTF modelUrl changed or if GLTF type but no URL
                    if (configData.type === 'GLTF' && isGltfInConfig && currentMesh.userData.modelUrl !== configData.modelUrl) {
                        console.log(`Model ${configData.id}: GLTF URL changed, needs replacement.`);
                        needsReplacement = true;
                    } else if (configData.type === 'GLTF' && !isGltfInConfig && currentMesh.userData.type === 'GLTF') { // GLTF type but now no URL
                        console.log(`Model ${configData.id}: GLTF type but modelUrl is empty, removing existing GLTF model.`);
                        needsReplacement = true;
                    }
                    // Check if primitive type changed or if it was a GLTF and now a primitive
                    else if (configData.type !== 'GLTF' && currentMesh.userData.type !== configData.type) {
                        console.log(`Model ${configData.id}: Type changed (GLTF to primitive or primitive to another primitive), needs replacement.`);
                        needsReplacement = true;
                    } else {
                        console.log(`Model ${configData.id}: Exists and modelUrl/type matches, will update properties.`);
                    }
                } else if (isGltfInConfig || configData.type !== 'GLTF') { // No current mesh but config specifies a new one
                    console.log(`Model ${configData.id}: No existing mesh, will create new model.`);
                    needsReplacement = true;
                } else {
                    console.log(`Model ${configData.id}: No mesh and no modelUrl/primitive type, skipping creation.`);
                }


                if (needsReplacement) {
                    if (currentMesh) {
                        // Crucial: Detach TransformControls and clear selectedObject *before* disposing
                        if (selectedObject && selectedObject.uuid === currentMesh.uuid) {
                            if (transformControls) {
                                transformControls.detach(); // Detach TransformControls
                                transformControls.visible = false; // Hide it immediately
                            }
                            selectedObject = null; // Clear selected object state
                            console.log(`Detached TransformControls and cleared selected object for model ${configData.id} before disposal.`);
                        }
                        disposeObject(currentMesh);
                        console.log(`Removed old mesh for config ID: ${configData.id}`);
                    }

                    if (isGltfInConfig) {
                        console.log(`Loading GLTF model for ${configData.id} from: ${configData.modelUrl.substring(0, 100)}...`);
                        modelLoadStatusMap.set(configData.id, true);
                        updateModelLoadingStatusUI(configData.id, true);
                        try {
                            const gltf = await loader.loadAsync(configData.modelUrl, (progress) => {
                                const percent = Math.round((progress.loaded / progress.total) * 100);
                                console.log(`Model ${configData.id} loading progress: ${percent}%`);
                            });
                            newMesh = gltf.scene;
                            newMesh.name = `model_group_${configData.id}`;
                            newMesh.userData.isGltf = true;
                            // Set models to cast and receive shadows, and keep their original materials
                            newMesh.traverse(function (child) {
                                if (child.isMesh) {
                                    child.castShadow = configData.castShadow;
                                    child.receiveShadow = configData.receiveShadow; // Fixed: should be configData.receiveShadow
                                    // Log material properties for debugging GLTF texture issues
                                    console.log(`  GLTF Mesh: ${child.name}, Material Type: ${child.material.type}`);
                                    if (child.material.map) {
                                        console.log(`    - Has texture map. Texture name: ${child.material.map.name || 'N/A'}`);
                                    } else {
                                        console.log(`    - No texture map found.`);
                                    }
                                }
                            });
                            console.log(`Successfully loaded GLTF model for ${configData.id}.`);
                            showMessageBox(`模型 "${configData.id}" 加载成功!`);
                        } catch (error) {
                            console.error(`Error loading GLTF model for ${configData.id} from ${configData.modelUrl.substring(0, 100)}...:`, error);
                            showMessageBox(`GLTF 模型加载失败 (${configData.id}). 错误: ${error.message.substring(0, 80)}... 请检查 URL 或文件。`);
                            newMesh = null;
                        } finally {
                            modelLoadStatusMap.set(configData.id, false);
                            updateModelLoadingStatusUI(configData.id, false);
                        }
                    } else if (configData.type !== 'GLTF') { // Handle primitive types
                        let geometry;
                        if (configData.type === 'Sphere') {
                            geometry = new THREE.SphereGeometry(1, 32, 32);
                        } else if (configData.type === 'Box') {
                            geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                        } else if (configData.type === 'Torus') {
                            geometry = new THREE.TorusGeometry(1, 0.4, 32, 100);
                        } else if (configData.type === 'Plane') { // Handle Plane geometry
                             geometry = new THREE.PlaneGeometry(1, 1); // Size will be adjusted by scale
                        } else {
                            console.warn(`Unknown primitive type: ${configData.type}. Using BoxGeometry.`);
                            geometry = new THREE.BoxGeometry(1, 1, 1);
                        }

                        let material;
                        if (configData.materialType === 'Toon') {
                            material = new THREE.MeshToonMaterial({
                                color: new THREE.Color(configData.color),
                                gradientMap: createCustomToonGradientMap(
                                    configData.toonShadowColor, configData.toonBaseColor, configData.toonHighlightColor,
                                    configData.toonShadowThreshold, configData.toonHighlightThreshold, configData.toonSmoothness
                                )
                            });
                        } else { // Default to Standard
                            // For ground, it will always be a pure color now, no texture.
                            material = new THREE.MeshStandardMaterial({
                                color: new THREE.Color(configData.color),
                                metalness: 0.7, roughness: 0.3, emissive: 0x000000 // default emissive
                            });
                        }
                        newMesh = new THREE.Mesh(geometry, material);
                        newMesh.userData.isGltf = false; // Mark as primitive
                        newMesh.castShadow = configData.castShadow;
                        newMesh.receiveShadow = configData.receiveShadow;
                    } else { // If type is GLTF but no modelUrl or invalid type
                        newMesh = null;
                    }

                    if (newMesh instanceof THREE.Object3D) {
                        scene.add(newMesh);
                        newMesh.userData.configId = configData.id;
                        newMesh.userData.modelUrl = configData.modelUrl; // Store model URL
                        newMesh.userData.actionUrl = configData.actionUrl; // Store action URL
                        newMesh.userData.type = configData.type; // Store primitive type
                        newMesh.userData.materialType = configData.materialType; // Store material type

                        if (configData.position && Array.isArray(configData.position) && configData.position.length === 3) {
                            newMesh.position.fromArray(configData.position);
                        } else {
                            console.warn(`模型 ${configData.id}: 位置数组缺失或格式错误，默认设置为 [0,0,0]。`);
                            newMesh.position.set(0, 0, 0);
                        }
                        if (configData.scale && Array.isArray(configData.scale) && configData.scale.length === 3) {
                            newMesh.scale.set(configData.scale[0], configData.scale[1], configData.scale[2]);
                        } else {
                            console.warn(`模型 ${configData.id}: 缩放数组缺失或格式错误，默认设置为 [1,1,1]。`);
                            newMesh.scale.set(1, 1, 1);
                        }
                        if (configData.rotation && Array.isArray(configData.rotation) && configData.rotation.length === 3) {
                            newMesh.rotation.set(configData.rotation[0], configData.rotation[1], configData.rotation[2]);
                        } else {
                            console.warn(`模型 ${configData.id}: 旋转数组缺失或格式错误，默认设置为 [0,0,0]。`);
                            newMesh.rotation.set(0, 0, 0);
                        }
                        newMesh.userData.originalScale = newMesh.scale.clone();
                        console.log(`新模型 ${configData.id} 已添加/创建，位置 ${newMesh.position.toArray()}，缩放 ${newMesh.scale.toArray()}，旋转 ${newMesh.rotation.toArray()}。`);
                    } else {
                        console.error(`模型 ${configData.id}: 加载的对象不是有效的 THREE.Object3D。跳过添加到场景。`);
                        newMesh = null;
                    }
                } else {
                    newMesh = currentMesh;
                    // Update properties of existing mesh without re-creating
                    if (configData.position && Array.isArray(configData.position) && configData.position.length === 3) {
                        newMesh.position.set(configData.position[0], configData.position[1], configData.position[2]);
                    } else {
                        console.warn(`模型 ${configData.id}: 现有位置数组缺失或格式错误，保持当前网格位置。`);
                    }
                    if (configData.scale && Array.isArray(configData.scale) && configData.scale.length === 3) {
                        newMesh.scale.set(configData.scale[0], configData.scale[1], configData.scale[2]);
                    } else {
                        console.warn(`模型 ${configData.id}: 现有缩放数组缺失或格式错误，保持当前网格缩放。`);
                    }
                    if (configData.rotation && Array.isArray(configData.rotation) && configData.rotation.length === 3) {
                        newMesh.rotation.set(configData.rotation[0], configData.rotation[1], configData.rotation[2]);
                    } else {
                        console.warn(`模型 ${configData.id}: 现有旋转数组缺失或格式错误，保持当前网格旋转。`);
                    }
                    newMesh.userData.originalScale.copy(newMesh.scale);
                    newMesh.userData.modelUrl = configData.modelUrl; // Update model URL
                    newMesh.userData.actionUrl = configData.actionUrl; // Update action URL
                    newMesh.userData.type = configData.type; // Update primitive type
                    newMesh.userData.materialType = configData.materialType; // Update material type
                    newMesh.castShadow = configData.castShadow;
                    newMesh.receiveShadow = configData.receiveShadow; // Corrected line

                    // Update material properties if not a GLTF or if material type changed
                    // GLTF models will preserve their original materials unless explicitly overridden
                    if (!newMesh.userData.isGltf) { // Only update for primitives
                        if (newMesh.material) {
                            if (Array.isArray(newMesh.material)) {
                                newMesh.material.forEach(m => m.dispose());
                            } else {
                                newMesh.material.dispose();
                            }
                        }
                        let material;
                        if (configData.materialType === 'Toon') {
                            material = new THREE.MeshToonMaterial({
                                color: new THREE.Color(configData.color),
                                gradientMap: createCustomToonGradientMap(
                                    configData.toonShadowColor, configData.toonBaseColor, configData.toonHighlightColor,
                                    configData.toonShadowThreshold, configData.toonHighlightThreshold, configData.toonSmoothness
                                )
                            });
                        } else { // Default to Standard
                            // For ground, it will always be a pure color now, no texture.
                            material = new THREE.MeshStandardMaterial({
                                color: new THREE.Color(configData.color), // Base color
                                metalness: 0.1, roughness: 0.8, emissive: 0x000000
                            });
                        }
                        newMesh.material = material;
                    }
                    // For GLTF models, `materialType` and `color` in config will be ignored, they use native materials.
                    // However, we still want to update `castShadow` and `receiveShadow` for GLTF models.
                    if (newMesh.userData.isGltf) {
                        newMesh.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = configData.castShadow;
                                child.receiveShadow = configData.receiveShadow; // Fixed: previously was configData.castShadow
                                // No material updates for GLTF here, they keep their native materials
                            }
                        });
                    }

                    console.log(`网格 ${configData.id} 属性已更新至位置 ${newMesh.position.toArray()}，缩放 ${newMesh.scale.toArray()}，旋转 ${newMesh.rotation.toArray()}。`);
                }
                // Only add models that are not the ground to interactive objects
                if (newMesh && newMesh.userData.configId !== 'model_ground') {
                    newInteractiveObjects.push(newMesh);
                }
                return newMesh;
            }).filter(Boolean);

            await Promise.all(loadPromises);

            modelsInSceneMap.forEach((meshToRemove, configId) => {
                if (!appConfig.models.some(m => m.id === configId)) {
                    if (selectedObject && selectedObject.uuid === meshToRemove.uuid) {
                        if (transformControls) {
                            transformControls.detach();
                        }
                            selectedObject = null;
                    }
                    disposeObject(meshToRemove);
                    console.log(`已移除配置中不再存在的网格: ${configId}`);
                }
            });

            interactiveObjects.length = 0;
            interactiveObjects.push(...newInteractiveObjects);
            document.getElementById('model-count').textContent = interactiveObjects.length;

            console.log("syncModelsWithScene: 模型已同步。");
        }


        // --- Setup Post-processing ---
        function setupPostProcessing() {
            console.log('setupPostProcessing: 初始化后期处理。');
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            // TEMP DEBUG: Comment out post-processing passes to check for GLTF texture issues.
            // If textures display correctly, re-enable these passes one by one to find the culprit.
            
            // SSAO Pass
            ssaoPass = new SSAARenderPass(scene, camera);
            ssaoPass.enabled = appConfig.ambientOcclusion.enabled;
            ssaoPass.radius = appConfig.ambientOcclusion.radius;
            ssaoPass.intensity = appConfig.ambientOcclusion.intensity;
            ssaoPass.bias = appConfig.ambientOcclusion.bias;
            composer.addPass(ssaoPass);

            // Bloom Pass
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                appConfig.filter.bloomStrength,
                appConfig.filter.bloomRadius,
                appConfig.filter.bloomThreshold
            );
            composer.addPass(bloomPass);

            // Custom Shader Pass (Fisheye, Chromatic Aberration, Dithering, Pixelation, Color Grading)
            customShaderPass = new ShaderPass(CustomShader);
            composer.addPass(customShaderPass);

            // Output Pass
            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            updateSceneParameters();
            console.log('setupPostProcessing: 后期处理已初始化。');
        }
        
        // --- Dynamically create Bayer Matrix Texture ---
        function createBayerTexture() {
            const size = 8;
            const bayerMatrix = [
                [ 0, 32,  8, 40,  2, 34, 10, 42 ], [ 48, 16, 56, 24, 50, 18, 58, 26 ],
                [ 12, 44,  4, 36, 14, 46,  6, 38 ], [ 60, 28, 52, 20, 62, 30, 54, 22 ],
                [ 3, 35, 11, 43,  1, 33,  9, 41 ], [ 51, 19, 59, 27, 49, 17, 57, 25 ],
                [ 15, 47,  7, 39, 13, 45,  5, 37 ], [ 63, 31, 55, 23, 61, 29, 53, 21 ]
            ];
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const value = Math.floor(bayerMatrix[i][j] / 64 * 255);
                    const index = (i * size + j) * 4;
                    data[index] = value;
                    data[index + 1] = value;
                    data[index + 2] = value;
                    data[index + 3] = 255;
                }
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        // --- Interaction Events ---
        function onMouseMove(event) {
            // Mousemove for hover/selection is always active.
            // URL jump is handled by onMouseClick, not here.
            if (controls.isDragging) { // Still prevent hover during OrbitControls drag
                if (highlightedObject) {
                    resetHighlightedObject();
                }
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Intersect with all meshes in interactiveObjects
            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            let currentHoveredObject = null;

            if (intersects.length > 0) {
                // Find the top-level parent object that has the originalScale and configId
                let obj = intersects[0].object;
                while (obj && (!obj.userData.originalScale || !obj.userData.configId) && obj.parent) {
                    obj = obj.parent;
                }
                if (obj && obj.userData.originalScale && obj.userData.configId) {
                    currentHoveredObject = obj;
                }
            }

            if (currentHoveredObject !== highlightedObject) {
                if (highlightedObject) {
                    resetHighlightedObject();
                }

                highlightedObject = currentHoveredObject;

                // Only apply hover if not already selected
                if (highlightedObject && highlightedObject.uuid !== (selectedObject && selectedObject.uuid)) { 
                    if (hoverAnimation) hoverAnimation.kill();
                    gsap.to(highlightedObject.scale, {
                        x: highlightedObject.userData.originalScale.x * appConfig.interaction.hoverScaleFactor,
                        y: highlightedObject.userData.originalScale.y * appConfig.interaction.hoverScaleFactor,
                        z: highlightedObject.userData.originalScale.z * appConfig.interaction.hoverScaleFactor,
                        duration: appConfig.interaction.hoverDuration,
                        ease: "power2.out"
                    });
                    highlightedObject.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // To support different material types, check if material has emissive
                            // Only apply emissive if the material doesn't have an emissive map
                            if (child.material.emissive && !child.material.emissiveMap) {
                                child.material.emissive.setHex(0x111111);
                                child.material.emissiveIntensity = appConfig.interaction.hoverEmissiveIntensity;
                            }
                        }
                    });
                }
            }
        }

        function resetHighlightedObject() {
            if (highlightedObject) {
                if (hoverAnimation) hoverAnimation.kill();
                gsap.to(highlightedObject.scale, {
                    x: highlightedObject.userData.originalScale.x,
                    y: highlightedObject.userData.originalScale.y,
                    z: highlightedObject.userData.originalScale.z,
                    duration: appConfig.interaction.hoverDuration,
                    ease: "power2.out"
                });
                highlightedObject.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // If the currently hovered object is not the selected object, reset its emissive
                        if (highlightedObject.uuid !== (selectedObject && selectedObject.uuid)) {
                             if (child.material.emissive && !child.material.emissiveMap) {
                                child.material.emissive.setHex(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        }
                    }
                });
                highlightedObject = null;
            }
        }

        function onMouseClick(event) {
            console.log(`onMouseClick: isPanelVisible = ${isPanelVisible}, event target = ${event.target.id}`);
            // If the panel is visible, we prevent URL jump, but allow selection.
            // Pointer events on canvas are managed by CSS pointer-events property
            // and `isPanelVisible` variable.
            
            // Prevent URL jump if OrbitControls is dragging
            if (controls.isDragging) {
                console.log("交互受阻：OrbitControls 正在拖拽。");
                // Even if panel is open, if dragging, don't select either.
                return; 
            }
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects, true);
            
            let clickedObject = null;
            if (intersects.length > 0) {
                // Find the top-level parent object that has the configId and is part of our interactiveObjects tracking
                let obj = intersects[0].object;
                while (obj && !obj.userData.configId && obj.parent) {
                    obj = obj.parent;
                }
                if (obj && interactiveObjects.includes(obj)) {
                    clickedObject = obj;
                }
            }

            if (clickedObject) {
                selectObject(clickedObject); // Always select the object

                // Only open URL if panel is NOT visible
                if (!isPanelVisible && clickedObject.userData.actionUrl) {
                    window.open(clickedObject.userData.actionUrl, '_blank');
                    console.log(`已打开链接: ${clickedObject.userData.actionUrl} 对于模型 ${clickedObject.userData.configId}`);
                } else if (isPanelVisible) {
                    console.log(`面板打开时点击模型 ${clickedObject.userData.configId}，不进行网页跳转。`);
                }
            } else {
                // If nothing was clicked, deselect any currently selected object
                selectObject(null);
                console.log(`未点击任何互动模型。`);
            }
        }


        function selectObject(object) {
            console.log(`selectObject: isPanelVisible = ${isPanelVisible}, selectedObject before = ${selectedObject ? selectedObject.userData.configId : 'none'}`);
            // Detach TransformControls from the previously selected object if it exists
            if (transformControls && transformControls.object) {
                transformControls.detach();
                transformControls.visible = false; // Ensure visibility is off
                console.log(`TransformControls 已从先前选定的对象分离。`);
            }

            // Reset emissive for the previously selected object
            if (selectedObject) { // This `selectedObject` is the *old* one
                selectedObject.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // Reset emissive only if there's no emissive map
                        if (child.material.emissive && !child.material.emissiveMap) {
                            child.material.emissive.setHex(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    }
                });
            }

            selectedObject = object; // Update selectedObject to the new one

            if (selectedObject && selectedObject.parent) { // Crucial check: new selectedObject must be in scene graph
                // Apply emissive to the newly selected object (only if no emissive map)
                selectedObject.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (child.material.emissive && !child.material.emissiveMap) {
                            child.material.emissive.setHex(0x888800); // Yellowish highlight
                            child.material.emissiveIntensity = 0.5;
                        }
                    }
                });
                // Attach TransformControls to the newly selected object if panel is visible
                if (transformControls && isPanelVisible) { // Only attach if panel is visible
                    transformControls.attach(selectedObject);
                    transformControls.setMode('translate'); // Default mode
                    transformControls.visible = true;
                    console.log(`TransformControls 已附加到 ${selectedObject.userData.configId}。`);
                } else {
                    console.log(`TransformControls 未附加 (isPanelVisible: ${isPanelVisible})。`);
                }
                // Scroll UI to the selected model's card
                const modelConfig = appConfig.models.find(m => m.id === selectedObject.userData.configId);
                if (modelConfig) {
                    const modelCardElement = document.getElementById(`model-card-${modelConfig.id}`);
                    document.querySelectorAll('.model-card').forEach(card => {
                        card.classList.remove('border-yellow-500', 'ring-2', 'ring-yellow-500');
                    });
                    if (modelCardElement) {
                        modelCardElement.classList.add('border-yellow-500', 'ring-2', 'ring-yellow-500');
                        modelCardElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
                console.log(`已选定对象: ${selectedObject.userData.configId}`);
            } else {
                // If nothing is selected or object is not in scene graph, ensure all highlights are removed
                document.querySelectorAll('.model-card').forEach(card => {
                    card.classList.remove('border-yellow-500', 'ring-2', 'ring-yellow-500');
                });
                console.log('未选中任何对象或选定对象不在场景图中。');
            }
        }

        // Helper to update UI inputs for a specific model (used by TransformControls)
        function updateModelUIInputs(modelId, position, scale, rotation) { // Added rotation
            const modelCard = document.getElementById(`model-card-${modelId}`);
            if (modelCard) {
                const posXNum = modelCard.querySelector(`#model-pos-x-num-${modelId}`);
                const posYNum = modelCard.querySelector(`#model-pos-y-num-${modelId}`);
                const posZNum = modelCard.querySelector(`#model-pos-z-num-${modelId}`);
                const scaleXNum = modelCard.querySelector(`#model-scale-x-num-${modelId}`);
                const scaleYNum = modelCard.querySelector(`#model-scale-y-num-${modelId}`);
                const scaleZNum = modelCard.querySelector(`#model-scale-z-num-${modelId}`);
                const rotXNum = modelCard.querySelector(`#model-rot-x-num-${modelId}`); // New rotation inputs
                const rotYNum = modelCard.querySelector(`#model-rot-y-num-${modelId}`);
                const rotZNum = modelCard.querySelector(`#model-rot-z-num-${modelId}`);

                if (posXNum) posXNum.value = position.x.toFixed(2);
                if (posYNum) posYNum.value = position.y.toFixed(2);
                if (posZNum) posZNum.value = position.z.toFixed(2);
                if (scaleXNum) scaleXNum.value = scale.x.toFixed(2);
                if (scaleYNum) scaleYNum.value = scale.y.toFixed(2);
                if (scaleZNum) scaleZNum.value = scale.z.toFixed(2);
                if (rotXNum) rotXNum.value = THREE.MathUtils.radToDeg(rotation.x).toFixed(2); // Convert to degrees for UI
                if (rotYNum) rotYNum.value = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
                if (rotZNum) rotZNum.value = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);
            }
        }
        
        // --- Window Resize ---
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            composer.setSize(width, height);

            if (customShaderPass && customShaderPass.uniforms) { 
                customShaderPass.uniforms.resolution.value.set(width, height);
            }
            if (bloomPass) {
                bloomPass.setSize(width, height);
            }
            if (ssaoPass) {
                ssaoPass.setSize(width, height);
            }


            // Update gradient plane size if it exists
            if (gradientBackgroundPlane) {
                const aspect = width / height;
                // Adjust scale or other properties as needed to keep it covering the viewport
                // For a sphere, its geometry handles the scaling, but ensure it's larger than camera far clip
                gradientBackgroundPlane.scale.set(1, 1, 1); // Reset scale first
                gradientBackgroundPlane.scale.x = aspect;
                gradientBackgroundPlane.scale.y = aspect;
                // Alternatively, adjust the sphere radius
                gradientBackgroundPlane.geometry.dispose();
                gradientBackgroundPlane.geometry = new THREE.SphereGeometry(Math.max(500, camera.far * 0.8), 32, 32);
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (transformControls && typeof transformControls.update === 'function') {
                transformControls.update();
            }
            // If post-processing is enabled (i.e., composer is initialized), use composer.render()
            // Otherwise, use renderer.render()
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // --- UI Control Logic Variables ---
        let controlsPanel, adminControlsContent;
        let cameraFovNum, cameraFovRange, cameraPosXNum, cameraPosXRange, cameraPosYNum, cameraPosYRange, cameraPosZNum, cameraPosZRange;
        let fogEnabledToggle, fogColorInput, fogOpacityNum, fogOpacityRange, fogNearNum, fogNearRange, fogFarNum, fogFarRange, fogControlsDiv; // Fog variables
        let backgroundModeSelect, sceneBackgroundColor, gradientColor1, gradientColor2, hdrUploadInput, displayHdrAsBackgroundToggle;
        let solidColorControlsDiv, gradientColorControlsDiv, hdrControlsDiv;

        let lightAmbientNum, lightAmbientRange, ambientLightColor;
        let lightDirectionalNum, lightDirectionalRange, directionalLightColor, lightDirPosXNum, lightDirPosXRange, lightDirPosYNum, lightDirPosYRange, lightDirPosZNum, lightDirPosZRange;
        let ssaoEnabledToggle, ssaoRadiusNum, ssaoRadiusRange, ssaoIntensityNum, ssaoIntensityRange, ssaoBiasNum, ssaoBiasRange, ssaoControlsDiv; // SSAO variables

        let modelListDiv, uploadModelBtn, addPrimitiveModelBtn, clearAllModelsBtn; // Added addPrimitiveModelBtn
        let hoverScaleFactorNum, hoverScaleFactorRange, hoverDurationNum, hoverDurationRange, hoverEmissiveIntensityNum, hoverEmissiveIntensityRange;
        let filterFisheyeEnabled, filterFisheyeStrengthNum, filterFisheyeStrengthRange;
        let filterAberrationEnabled, filterDitheringEnabled, filterPixelEnabled, filterBloomEnabled, filterColorGradingEnabled;
        let filterAberrationNum, filterAberrationRange, filterDitheringNum, filterDitheringRange, filterDitheringColorResolutionSelect, filterPixelGridSizeSelect;
        let filterBloomStrengthNum, filterBloomStrengthRange, filterBloomRadiusNum, filterBloomRadiusRange, filterBloomThresholdNum, filterBloomThresholdRange;
        let filterBrightnessNum, filterBrightnessRange, filterContrastNum, filterContrastRange, filterSaturationNum, filterSaturationRange, filterHueOffsetNum, filterHueOffsetRange, filterGammaNum, filterGammaRange;
        let generateConfigBtn;


        /**
         * Initializes dual slider and number input functionality.
         * Links a range input and a number input so they update each other.
         * @param {string} baseId The base ID for the elements (e.g., 'camera-fov')
         * @param {Function} updateFn The function to call when the value changes (e.g., debouncedUpdateConfigFromUI)
         */
        function setupSliderNumberInput(baseId, updateFn) {
            const numInput = document.getElementById(`${baseId}-num`);
            const rangeInput = document.getElementById(`${baseId}-range`);

            if (numInput && rangeInput) {
                numInput.addEventListener('input', () => {
                    rangeInput.value = numInput.value;
                    updateFn();
                });

                rangeInput.addEventListener('input', () => {
                    numInput.value = rangeInput.value;
                    updateFn();
                });
            } else if (numInput) { // Fallback if range input not present (for model properties)
                numInput.addEventListener('input', updateFn);
            }
        }

        /**
         * Fills UI fields and initializes all dynamic components.
         */
        function renderUI() {
            cameraFovNum.value = appConfig.camera.fov;
            cameraPosXNum.value = appConfig.camera.position[0];
            cameraPosYNum.value = appConfig.camera.position[1];
            cameraPosZNum.value = appConfig.camera.position[2];
            cameraFovRange.value = appConfig.camera.fov;
            cameraPosXRange.value = appConfig.camera.position[0];
            cameraPosYRange.value = appConfig.camera.position[1];
            cameraPosZRange.value = appConfig.camera.position[2];

            fogEnabledToggle.checked = appConfig.fog.enabled;
            fogColorInput.value = appConfig.fog.color;
            fogOpacityNum.value = appConfig.fog.fogOpacity; // Set opacity
            fogOpacityRange.value = appConfig.fog.fogOpacity; // Set opacity
            fogNearNum.value = appConfig.fog.near;
            fogNearRange.value = appConfig.fog.near;
            fogFarNum.value = appConfig.fog.far;
            fogFarRange.value = appConfig.fog.far;
            updateFogControlsState();

            backgroundModeSelect.value = appConfig.background.mode;
            sceneBackgroundColor.value = appConfig.background.color;
            gradientColor1.value = appConfig.background.gradientColor1;
            gradientColor2.value = appConfig.background.gradientColor2;
            displayHdrAsBackgroundToggle.checked = appConfig.background.displayHdrAsBackground;
            updateBackgroundModeUI(); // Call to update visibility of background controls

            lightAmbientNum.value = appConfig.lighting.ambientIntensity;
            lightDirectionalNum.value = appConfig.lighting.directionalIntensity;
            lightDirPosXNum.value = appConfig.lighting.directionalPosition[0];
            lightDirPosYNum.value = appConfig.lighting.directionalPosition[1];
            lightDirPosZNum.value = appConfig.lighting.directionalPosition[2];
            lightAmbientRange.value = appConfig.lighting.ambientIntensity;
            lightDirectionalRange.value = appConfig.lighting.directionalIntensity;
            lightDirPosXRange.value = appConfig.lighting.directionalPosition[0];
            lightDirPosYRange.value = appConfig.lighting.directionalPosition[1];
            lightDirPosZRange.value = appConfig.lighting.directionalPosition[2];
            ambientLightColor.value = appConfig.lighting.ambientColor; // Set ambient color
            directionalLightColor.value = appConfig.lighting.directionalColor; // Set directional color

            ssaoEnabledToggle.checked = appConfig.ambientOcclusion.enabled;
            ssaoRadiusNum.value = appConfig.ambientOcclusion.radius;
            ssaoRadiusRange.value = appConfig.ambientOcclusion.radius;
            ssaoIntensityNum.value = appConfig.ambientOcclusion.intensity;
            ssaoIntensityRange.value = appConfig.ambientOcclusion.intensity;
            ssaoBiasNum.value = appConfig.ambientOcclusion.bias;
            ssaoBiasRange.value = appConfig.ambientOcclusion.bias;
            updateSSAOControlsState();

            hoverScaleFactorNum.value = appConfig.interaction.hoverScaleFactor;
            hoverScaleFactorRange.value = appConfig.interaction.hoverScaleFactor;
            hoverDurationNum.value = appConfig.interaction.hoverDuration;
            hoverDurationRange.value = appConfig.interaction.hoverDuration;
            hoverEmissiveIntensityNum.value = appConfig.interaction.hoverEmissiveIntensity;
            hoverEmissiveIntensityRange.value = appConfig.interaction.hoverEmissiveIntensity;

            filterFisheyeEnabled.checked = appConfig.filter.fisheyeEnabled;
            filterAberrationEnabled.checked = appConfig.filter.aberrationEnabled;
            filterDitheringEnabled.checked = appConfig.filter.ditheringEnabled;
            filterPixelEnabled.checked = appConfig.filter.pixelEnabled;
            filterBloomEnabled.checked = appConfig.filter.bloomEnabled;
            filterColorGradingEnabled.checked = appConfig.filter.colorGradingEnabled;

            filterFisheyeStrengthNum.value = appConfig.filter.fisheyeStrength;
            filterAberrationNum.value = appConfig.filter.aberrationAmount;
            filterDitheringNum.value = appConfig.filter.ditheringMultiply;
            filterPixelGridSizeSelect.value = appConfig.filter.pixelGridSize;
            filterDitheringColorResolutionSelect.value = appConfig.filter.ditheringColorResolution;
            filterBloomStrengthNum.value = appConfig.filter.bloomStrength;
            filterBloomRadiusNum.value = appConfig.filter.bloomRadius;
            filterBloomThresholdNum.value = appConfig.filter.bloomThreshold;
            filterBrightnessNum.value = appConfig.filter.brightness;
            filterContrastNum.value = appConfig.filter.contrast;
            filterSaturationNum.value = appConfig.filter.saturation;
            filterHueOffsetNum.value = appConfig.filter.hueOffset;
            filterGammaNum.value = appConfig.filter.gamma;
            filterFisheyeStrengthRange.value = appConfig.filter.fisheyeStrength;
            filterAberrationRange.value = appConfig.filter.aberrationAmount;
            filterDitheringRange.value = appConfig.filter.ditheringMultiply;
            filterBloomStrengthRange.value = appConfig.filter.bloomStrength;
            filterBloomRadiusRange.value = appConfig.filter.bloomRadius;
            filterBloomThresholdRange.value = appConfig.filter.bloomThreshold;
            filterBrightnessRange.value = appConfig.filter.brightness;
            filterContrastRange.value = appConfig.filter.contrast;
            filterSaturationRange.value = appConfig.filter.saturation;
            filterHueOffsetRange.value = appConfig.filter.hueOffset;
            filterGammaRange.value = appConfig.filter.gamma;

            renderModels(); // This will create/update the model cards in the UI
            updateFilterControlsState();
            document.getElementById('model-count').textContent = appConfig.models.length; // Update model count
        }

        /**
         * Toggles the display state of a collapsible section.
         */
        function toggleCollapsible(contentDiv, arrowIcon) {
            contentDiv.classList.toggle('active');
            arrowIcon.classList.toggle('rotate-90');

            if (contentDiv.classList.contains('active')) {
                contentDiv.style.maxHeight = contentDiv.scrollHeight + 'px'; 
            } else {
                contentDiv.style.maxHeight = contentDiv.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    contentDiv.style.maxHeight = '0';
                });
            }
        }

        /**
         * Dynamically renders the model list.
         */
        function renderModels() {
            console.log('renderModels: Re-rendering model list UI.');
            modelListDiv.innerHTML = ''; // Clear existing content
            if (appConfig.models.length === 0) {
                modelListDiv.innerHTML = '<p class="text-gray-400 text-sm italic text-center py-4">点击下方按钮添加模型</p>';
            }

            appConfig.models.forEach((model, index) => {
                const modelCard = document.createElement('div');
                modelCard.id = `model-card-${model.id}`; 
                modelCard.classList.add('model-card'); // Add a class for easy selection
                if (selectedObject && selectedObject.userData.configId === model.id) {
                    modelCard.classList.add('border-yellow-500', 'ring-2', 'ring-yellow-500');
                }

                const isLoading = modelLoadStatusMap.get(model.id); // Get loading status
                const isGltfModel = model.type === 'GLTF';
                // Check model ID to specifically target the ground model for removal prevention
                const isGroundModel = model.id === 'model_ground'; 

                modelCard.className += ' bg-gray-900 p-3 rounded-md shadow-inner mb-2 border border-gray-700';
                modelCard.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-sm font-semibold text-gray-200">
                            模型 (${model.id})
                        </h3>
                        <span id="model-load-status-${model.id}" class="text-orange-300 ml-2 ${isLoading ? '' : 'hidden'}">
                            ${isLoading ? '加载中... <span class="loader inline-block align-middle"></span>' : ''}
                        </span>
                        <button data-id="${model.id}" class="remove-model-btn text-red-500 hover:text-red-400 transition duration-150 ${isGroundModel ? 'hidden' : ''}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="currentColor">
                                <path fill-rule="evenodd" d="M16 1.75V3h5.25a.75.75 0 010 1.5H2.75a.75.75 0 010-1.5H8V1.75C8 .784 8.784 0 9.75 0h4.5C15.216 0 16 .784 16 1.75zM11 7.25a.75.75 0 10-1.5 0v9.5a.75.75 0 001.5 0v-9.5zM14.25 7.25a.75.75 0 10-1.5 0v9.5a.75.75 0 001.5 0v-9.5zM17.5 4.75V19.25a2.75 2.75 0 01-2.75 2.75H9.25A2.75 2.75 0 016.5 19.25V4.75H4.25a.75.75 0 000 1.5h15.5a.75.75 0 000-1.5H17.5z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                    <div class="grid grid-cols-1 gap-2">
                        <div>
                            <label for="model-type-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">类型</label>
                            <select id="model-type-${model.id}" class="model-type w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-xs">
                                <option value="GLTF">GLTF/GLB</option>
                                <option value="Sphere">球体</option>
                                <option value="Box">立方体</option>
                                <option value="Torus">圆环</option>
                                <option value="Plane">平面 (地面)</option>
                            </select>
                        </div>
                        <div class="${isGltfModel ? 'hidden' : ''}" id="model-material-type-section-${model.id}">
                            <label for="model-material-type-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">材质类型</label>
                            <select id="model-material-type-${model.id}" class="model-material-type w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-xs">
                                <option value="Standard">标准 (Standard)</option>
                                <option value="Toon">卡通 (Toon)</option>
                            </select>
                        </div>
                        <div class="${isGltfModel ? 'hidden' : ''}" id="model-color-section-${model.id}">
                            <label for="model-color-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">颜色</label>
                            <input type="color" id="model-color-${model.id}" value="${model.color || '#808080'}" class="model-color w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                        </div>
                        
                        <div class="col-span-full">
                            <label class="block text-xs font-medium text-gray-300 mb-0.5">位置 (X, Y, Z)</label>
                            <div class="grid grid-cols-3 gap-1.5">
                                <input type="number" id="model-pos-x-num-${model.id}" value="${model.position[0]}" step="0.1" class="rounded-sm">
                                <input type="number" id="model-pos-y-num-${model.id}" value="${model.position[1]}" step="0.1" class="rounded-sm">
                                <input type="number" id="model-pos-z-num-${model.id}" value="${model.position[2]}" step="0.1" class="rounded-sm">
                            </div>
                        </div>
                        <div class="col-span-full">
                            <label class="block text-xs font-medium text-gray-300 mb-0.5">缩放 (X, Y, Z)</label>
                            <div class="grid grid-cols-3 gap-1.5">
                                <input type="number" id="model-scale-x-num-${model.id}" value="${model.scale[0]}" step="0.01" class="rounded-sm">
                                <input type="number" id="model-scale-y-num-${model.id}" value="${model.scale[1]}" step="0.01" class="rounded-sm">
                                <input type="number" id="model-scale-z-num-${model.id}" value="${model.scale[2]}" step="0.01" class="rounded-sm">
                            </div>
                        </div>
                        <div class="col-span-full">
                            <label class="block text-xs font-medium text-gray-300 mb-0.5">旋转 (X, Y, Z - 角度)</label>
                            <div class="grid grid-cols-3 gap-1.5">
                                <input type="number" id="model-rot-x-num-${model.id}" value="${THREE.MathUtils.radToDeg(model.rotation[0]).toFixed(2)}" step="1" class="rounded-sm">
                                <input type="number" id="model-rot-y-num-${model.id}" value="${THREE.MathUtils.radToDeg(model.rotation[1]).toFixed(2)}" step="1" class="rounded-sm">
                                <input type="number" id="model-rot-z-num-${model.id}" value="${THREE.MathUtils.radToDeg(model.rotation[2]).toFixed(2)}" step="1" class="rounded-sm">
                            </div>
                        </div>

                        <div class="col-span-full ${isGltfModel ? '' : 'hidden'}" id="model-url-section-${model.id}">
                            <label for="model-modelUrl-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">模型 URL (.gltf/.glb)</label>
                            <input type="text" id="model-modelUrl-${model.id}" value="${model.modelUrl}" class="model-url w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-sm" placeholder="粘贴 GLTF/GLB URL">
                        </div>
                        <div class="col-span-full ${isGltfModel ? '' : 'hidden'}" id="model-file-upload-section-${model.id}">
                            <label for="model-file-upload-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">上传本地 GLTF/GLB 文件</label>
                            <input type="file" id="model-file-upload-${model.id}" accept=".gltf,.glb" class="model-file-upload w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-xs">
                            <p class="text-xs text-gray-400 mt-1">注意: 大文件可能影响性能或导致崩溃。</p>
                        </div>
                        <div class="col-span-full">
                            <label for="model-actionUrl-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">点击 URL</label>
                            <input type="text" id="model-actionUrl-${model.id}" value="${model.actionUrl}" class="action-url w-full p-1.5 bg-gray-600 border border-gray-700 rounded-sm focus:ring-blue-500 focus:border-blue-500 text-sm" placeholder="粘贴点击后打开的网站链接">
                        </div>
                        <div class="col-span-full flex items-center justify-between">
                            <label for="model-cast-shadow-${model.id}" class="text-xs font-medium text-gray-300">投射阴影</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="model-cast-shadow-${model.id}" ${model.castShadow ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="col-span-full flex items-center justify-between">
                            <label for="model-receive-shadow-${model.id}" class="text-xs font-medium text-gray-300">接收阴影</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="model-receive-shadow-${model.id}" ${model.receiveShadow ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <!-- Toon Material Specific Settings (Collapsible) -->
                    <div class="border-t border-gray-700 mt-5 pt-5 toon-settings-section ${model.materialType === 'Toon' && !isGltfModel ? 'block' : 'hidden'}">
                        <div class="collapsible-header" data-target="toon-settings-${model.id}">
                            <h4 class="text-md font-semibold text-gray-300">卡通材质细节</h4>
                            <svg class="h-4 w-4 text-gray-400 transition-transform arrow-icon" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <div id="toon-settings-${model.id}" class="collapsible-content">
                            <div class="grid grid-cols-1 gap-2 mt-3">
                                <div>
                                    <label for="toon-shadow-color-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">阴影颜色</label>
                                    <input type="color" id="toon-shadow-color-${model.id}" value="${model.toonShadowColor || '#400000'}" class="toon-shadow-color w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                                </div>
                                <div>
                                    <label for="toon-base-color-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">基础颜色</label>
                                    <input type="color" id="toon-base-color-${model.id}" value="${model.toonBaseColor || model.color || '#808080'}" class="toon-base-color w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                                </div>
                                <div>
                                    <label for="toon-highlight-color-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">高光颜色</label>
                                    <input type="color" id="toon-highlight-color-${model.id}" value="${model.toonHighlightColor || '#FFA07A'}" class="toon-highlight-color w-full h-8 p-0 border border-gray-600 rounded-sm cursor-pointer">
                                </div>
                                <div>
                                    <label for="toon-shadow-threshold-num-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">阴影阈值</label>
                                    <div class="slider-number-group">
                                        <input type="range" id="toon-shadow-threshold-range-${model.id}" value="${model.toonShadowThreshold || 0.3}" step="0.05" min="0" max="1">
                                        <input type="number" id="toon-shadow-threshold-num-${model.id}" value="${model.toonShadowThreshold || 0.3}" step="0.05" min="0" max="1" class="rounded-sm">
                                    </div>
                                </div>
                                <div>
                                    <label for="toon-highlight-threshold-num-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">高光阈值</label>
                                    <div class="slider-number-group">
                                        <input type="range" id="toon-highlight-threshold-range-${model.id}" value="${model.toonHighlightThreshold || 0.7}" step="0.05" min="0" max="1">
                                        <input type="number" id="toon-highlight-threshold-num-${model.id}" value="${model.toonHighlightThreshold || 0.7}" step="0.05" min="0" max="1" class="rounded-sm">
                                    </div>
                                </div>
                                <div>
                                    <label for="toon-smoothness-num-${model.id}" class="block text-xs font-medium text-gray-300 mb-0.5">柔和度</label>
                                    <div class="slider-number-group">
                                        <input type="range" id="toon-smoothness-range-${model.id}" value="${model.toonSmoothness || 0}" step="0.05" min="0" max="0.5">
                                        <input type="number" id="toon-smoothness-num-${model.id}" value="${model.toonSmoothness || 0}" step="0.05" min="0" max="0.5" class="rounded-sm">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                modelListDiv.appendChild(modelCard);

                // Initialize UI elements and event listeners for the new model card
                const modelTypeSelect = modelCard.querySelector(`#model-type-${model.id}`);
                const modelMaterialTypeSelect = modelCard.querySelector(`#model-material-type-${model.id}`);
                const modelColorSection = modelCard.querySelector(`#model-color-section-${model.id}`);
                const modelMaterialTypeSection = modelCard.querySelector(`#model-material-type-section-${model.id}`);
                const modelUrlSection = modelCard.querySelector(`#model-url-section-${model.id}`);
                const modelFileUploadSection = modelCard.querySelector(`#model-file-upload-section-${model.id}`);
                const toonSettingsSection = modelCard.querySelector('.toon-settings-section');


                modelTypeSelect.value = model.type;
                if (modelMaterialTypeSelect) modelMaterialTypeSelect.value = model.materialType;


                // Toggle visibility of material, color, URL/file upload based on model type
                const updateModelTypeUI = () => {
                    const currentType = modelTypeSelect.value;
                    const isGltf = currentType === 'GLTF';
                    
                    if (modelUrlSection) modelUrlSection.classList.toggle('hidden', !isGltf);
                    if (modelFileUploadSection) modelFileUploadSection.classList.toggle('hidden', !isGltf);
                    if (modelMaterialTypeSection) modelMaterialTypeSection.classList.toggle('hidden', isGltf);
                    if (modelColorSection) modelColorSection.classList.toggle('hidden', isGltf);
                    if (toonSettingsSection) toonSettingsSection.classList.toggle('hidden', isGltf || modelMaterialTypeSelect.value !== 'Toon');
                    
                    // Specific visibility for Plane type
                    if (isGroundModel) { // Changed to use isGroundModel variable
                        // Ensure GLTF-related sections are hidden for the ground plane
                        if (modelUrlSection) modelUrlSection.classList.add('hidden');
                        if (modelFileUploadSection) modelFileUploadSection.classList.add('hidden');
                        // Ensure material and color sections are visible for the ground plane
                        if (modelMaterialTypeSection) modelMaterialTypeSection.classList.remove('hidden');
                        if (modelColorSection) modelColorSection.classList.remove('hidden');
                        // Ensure toon settings are hidden for ground if it's not 'Toon'
                        if (toonSettingsSection) toonSettingsSection.classList.toggle('hidden', modelMaterialTypeSelect.value !== 'Toon');
                    }
                };
                updateModelTypeUI(); // Initial call
                modelTypeSelect.addEventListener('change', (e) => {
                    model.type = e.target.value;
                    updateModelTypeUI();
                    debouncedUpdateConfigFromUI();
                });

                // Toggle visibility of Toon settings based on material type
                if (modelMaterialTypeSelect) {
                    const updateMaterialTypeUI = () => {
                        const currentType = modelTypeSelect.value;
                        const isGltf = currentType === 'GLTF';
                        if (toonSettingsSection) {
                            toonSettingsSection.classList.toggle('hidden', isGltf || modelMaterialTypeSelect.value !== 'Toon');
                        }
                    };
                    updateMaterialTypeUI(); // Initial call
                    modelMaterialTypeSelect.addEventListener('change', (e) => {
                        model.materialType = e.target.value;
                        updateMaterialTypeUI();
                        debouncedUpdateConfigFromUI();
                    });
                }

                // Event listeners for basic model properties (now only numbers, no sliders)
                modelCard.querySelector(`#model-pos-x-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-pos-y-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-pos-z-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-scale-x-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-scale-y-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-scale-z-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                // Rotation listeners
                modelCard.querySelector(`#model-rot-x-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-rot-y-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-rot-z-num-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);

                if (modelCard.querySelector(`#model-color-${model.id}`)) { // Only for non-GLTF
                    modelCard.querySelector(`#model-color-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                }
               
                modelCard.querySelector(`#model-actionUrl-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-cast-shadow-${model.id}`).addEventListener('change', debouncedUpdateConfigFromUI);
                modelCard.querySelector(`#model-receive-shadow-${model.id}`).addEventListener('change', debouncedUpdateConfigFromUI);


                const modelUrlInput = modelCard.querySelector(`#model-modelUrl-${model.id}`);
                if (modelUrlInput) {
                    modelUrlInput.addEventListener('input', debouncedUpdateConfigFromUI);
                }

                const modelFileUploadInput = modelCard.querySelector(`#model-file-upload-${model.id}`);
                if (modelFileUploadInput) {
                    modelFileUploadInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            console.log(`File selected for model ${model.id}: ${file.name}, size: ${file.size} bytes.`);
                            const reader = new FileReader();
                            // Show loading status
                            modelLoadStatusMap.set(model.id, true);
                            updateModelLoadingStatusUI(model.id, true);

                            reader.onload = (readerEvent) => {
                                console.log(`FileReader loaded file for model ${model.id}.`);
                                model.modelUrl = readerEvent.target.result; // Update modelUrl
                                if (modelUrlInput) modelUrlInput.value = model.modelUrl; // Update text input with data URI
                                updateConfigFromUI();
                                // Update loading status
                                modelLoadStatusMap.set(model.id, false);
                                updateModelLoadingStatusUI(model.id, false);
                                const updatedModelMesh = interactiveObjects.find(obj => obj.userData.configId === model.id);
                                if (updatedModelMesh) {
                                    selectObject(updatedModelMesh);
                                    showMessageBox(`模型 "${file.name}" 已上传并选中!`);
                                }
                            };
                            reader.onerror = (readerEvent) => {
                                console.error(`FileReader error for model ${model.id}:`, readerEvent.target.error);
                                showMessageBox(`文件读取失败 (${file.name}). 错误: ${readerEvent.target.error.message}`);
                                // Update loading status
                                modelLoadStatusMap.set(model.id, false);
                                updateModelLoadingStatusUI(model.id, false);
                            };
                            reader.readAsDataURL(file);
                        } else {
                            console.log(`File input cleared for model ${model.id}.`);
                            model.modelUrl = ''; // Clear URL if no file selected
                            if (modelUrlInput) modelUrlInput.value = ''; // Clear UI input
                            updateConfigFromUI();
                            showMessageBox(`模型 "${model.id}" URL 已清除。`);
                        }
                    });
                }

                // Toon settings listeners
                const toonHeader = modelCard.querySelector(`.collapsible-header[data-target="toon-settings-${model.id}"]`);
                if (toonHeader) {
                    const toonContent = modelCard.querySelector(`#toon-settings-${model.id}`);
                    const toonArrow = toonHeader.querySelector('.arrow-icon');
                    toonHeader.addEventListener('click', () => {
                        toggleCollapsible(toonContent, toonArrow);
                    });

                    modelCard.querySelector(`#toon-shadow-color-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                    modelCard.querySelector(`#toon-base-color-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                    modelCard.querySelector(`#toon-highlight-color-${model.id}`).addEventListener('input', debouncedUpdateConfigFromUI);
                    setupSliderNumberInput(`toon-shadow-threshold-${model.id}`, debouncedUpdateConfigFromUI);
                    setupSliderNumberInput(`toon-highlight-threshold-${model.id}`, debouncedUpdateConfigFromUI);
                    setupSliderNumberInput(`toon-smoothness-${model.id}`, debouncedUpdateConfigFromUI);
                }

                modelCard.querySelector('.remove-model-btn').addEventListener('click', (e) => {
                    removeModel(e.currentTarget.dataset.id);
                });
            });

            const modelsContent = document.getElementById('models-settings-content');
            if (modelsContent && modelsContent.classList.contains('active')) {
                modelsContent.style.maxHeight = modelsContent.scrollHeight + 'px';
            }
        }

        /**
         * Adds a new GLTF/GLB model slot and prompts for upload.
         */
        function uploadModel() {
            console.log('uploadModel: Initiating GLTF/GLB model upload.');
            const newModelId = `model_${nextModelId++}`;
            appConfig.models.push({
                id: newModelId,
                modelUrl: '', // Initially empty, will be filled by file input
                actionUrl: '', // Default empty action URL
                position: [0, 0, 0],
                scale: [1, 1, 1],
                rotation: [0, 0, 0], // Default rotation
                type: 'GLTF',
                materialType: 'Standard', // This will be ignored for GLTF models
                receiveShadow: true,
                castShadow: true
            });
            renderModels(); // Render the new model card in the UI
            updateConfigFromUI(); // Trigger initial scene update

            const modelsContent = document.getElementById('models-settings-content');
            const modelsHeader = document.querySelector('.collapsible-header[data-target="models-settings-content"]');
            const modelsArrow = modelsHeader ? modelsHeader.querySelector('.arrow-icon') : null;
            if (modelsContent && modelsHeader && modelsArrow) {
                if (!modelsContent.classList.contains('active')) {
                    modelsContent.classList.add('active');
                    modelsArrow.classList.add('rotate-90');
                }
                modelsContent.style.maxHeight = modelsContent.scrollHeight + 'px';
            }

            // Immediately trigger file input for the newly added model
            const fileInput = document.getElementById(`model-file-upload-${newModelId}`);
            if (fileInput) {
                fileInput.click();
            } else {
                showMessageBox('无法找到新模型的输入，请手动上传。');
                console.error(`错误: 无法找到新模型 ${newModelId} 的文件输入。`);
            }
        }

        /**
         * Adds a new primitive model slot (Sphere, Box, Torus, Plane).
         */
        function addPrimitiveModel() {
            console.log('addPrimitiveModel: Adding new primitive model.');
            const newModelId = `model_${nextModelId++}`;
            appConfig.models.push({
                id: newModelId,
                type: 'Box', // Default to Box
                materialType: 'Standard',
                position: [0, 0, 0],
                scale: [1, 1, 1],
                rotation: [0, 0, 0], // Default rotation
                color: '#808080',
                modelUrl: '', // Primitives don't use modelUrl
                actionUrl: '',
                receiveShadow: true,
                castShadow: true
            });
            renderModels(); // Render the new model card in the UI
            updateConfigFromUI(); // Trigger initial scene update

            const modelsContent = document.getElementById('models-settings-content');
            const modelsHeader = document.querySelector('.collapsible-header[data-target="models-settings-content"]');
            const modelsArrow = modelsHeader ? modelsHeader.querySelector('.arrow-icon') : null;
            if (modelsContent && modelsHeader && modelsArrow) {
                if (!modelsContent.classList.contains('active')) {
                    modelsContent.classList.add('active');
                    modelsArrow.classList.add('rotate-90');
                }
                modelsContent.style.maxHeight = modelsContent.scrollHeight + 'px';
            }
        }


        /**
         * Removes a model.
         */
        function removeModel(modelId) {
            console.log(`removeModel: 尝试移除模型 ${modelId}。`);
            // Find index by id, not array index, to handle ground plane
            const index = appConfig.models.findIndex(m => m.id === modelId);
            if (index !== -1) {
                // Prevent removal of the ground model by ID
                if (modelId === 'model_ground') {
                    showMessageBox('地面模型不能被移除。');
                    console.warn(`Attempted to remove ground model (${modelId}), which is not allowed.`);
                    return;
                }

                appConfig.models.splice(index, 1);
                if (selectedObject && selectedObject.userData.configId === modelId) {
                    if (transformControls) {
                        transformControls.detach();
                    }
                    selectedObject = null;
                }
                renderModels(); // Re-render the UI to remove the model card
                updateConfigFromUI();
                showMessageBox(`模型 "${modelId}" 已删除。`);
                console.log(`成功移除模型 ${modelId}。`);
            } else {
                showMessageBox(`模型 "${modelId}" 未找到。`);
                console.warn(`尝试移除不存在的模型: ${modelId}。`);
            }
        }

        /**
         * Clears all models.
         */
        function clearAllModels() {
            console.log('clearAllModels: 清除所有模型。');
            appConfig.models = [JSON.parse(JSON.stringify(defaultAppConfig.models.find(m => m.id === 'model_ground')))]; // Keep only default ground
            if (selectedObject) {
                if (transformControls) {
                    transformControls.detach();
                }
                selectedObject = null;
            }
            interactiveObjects.forEach(obj => disposeObject(obj)); // Dispose all interactive objects from scene
            interactiveObjects.length = 0; // Clear interactive objects list
            modelLoadStatusMap.clear(); // Clear loading status map
            nextModelId = 0; // Reset model ID counter for non-ground models
            renderModels(); // Re-render UI
            updateConfigFromUI(); // Update scene
            showMessageBox('所有模型已清除。');
            console.log('所有模型成功清除。');
        }


        /**
         * Updates the config object based on UI field values and triggers scene update.
         */
        function updateConfigFromUI() {
            console.log('updateConfigFromUI: 从 UI 收集数据并更新 appConfig。');
            appConfig.camera.fov = parseFloat(cameraFovNum.value) || 50; // Use 50 as default
            appConfig.camera.position = [
                parseFloat(cameraPosXNum.value) || 0,
                parseFloat(cameraPosYNum.value) || 0,
                parseFloat(cameraPosZNum.value) || 0
            ];

            appConfig.fog.enabled = fogEnabledToggle.checked;
            appConfig.fog.color = fogColorInput.value;
            appConfig.fog.fogOpacity = parseFloat(fogOpacityNum.value) || 1.0; // Read opacity
            appConfig.fog.near = parseFloat(fogNearNum.value) || 10;
            appConfig.fog.far = parseFloat(fogFarNum.value) || 30;

            appConfig.background.mode = backgroundModeSelect.value;
            appConfig.background.color = sceneBackgroundColor.value;
            appConfig.background.gradientColor1 = gradientColor1.value;
            appConfig.background.gradientColor2 = gradientColor2.value;
            appConfig.background.displayHdrAsBackground = displayHdrAsBackgroundToggle.checked;

            appConfig.lighting.ambientIntensity = parseFloat(lightAmbientNum.value) || 1.1;
            appConfig.lighting.ambientColor = ambientLightColor.value; // Get ambient color
            appConfig.lighting.directionalIntensity = parseFloat(lightDirectionalNum.value) || 2.5;
            appConfig.lighting.directionalColor = directionalLightColor.value; // Get directional color
            appConfig.lighting.directionalPosition = [
                parseFloat(lightDirPosXNum.value) || 0,
                parseFloat(lightDirPosYNum.value) || 0,
                parseFloat(lightDirPosZNum.value) || 0
            ];

            appConfig.ambientOcclusion.enabled = ssaoEnabledToggle.checked;
            appConfig.ambientOcclusion.radius = parseFloat(ssaoRadiusNum.value) || 2;
            appConfig.ambientOcclusion.intensity = parseFloat(ssaoIntensityNum.value) || 1;
            appConfig.ambientOcclusion.bias = parseFloat(ssaoBiasNum.value) || 0.001;

            appConfig.interaction.hoverScaleFactor = parseFloat(hoverScaleFactorNum.value) || 1.1;
            appConfig.interaction.hoverDuration = parseFloat(hoverDurationNum.value) || 0.3;
            appConfig.interaction.hoverEmissiveIntensity = parseFloat(hoverEmissiveIntensityNum.value) || 0.1;

            appConfig.filter.fisheyeEnabled = filterFisheyeEnabled.checked;
            appConfig.filter.aberrationEnabled = filterAberrationEnabled.checked;
            appConfig.filter.ditheringEnabled = filterDitheringEnabled.checked;
            appConfig.filter.pixelEnabled = filterPixelEnabled.checked;
            appConfig.filter.outlineEnabled = false; // No UI control, keep as false
            appConfig.filter.bloomEnabled = filterBloomEnabled.checked;
            appConfig.filter.colorGradingEnabled = filterColorGradingEnabled.checked;

            appConfig.filter.fisheyeStrength = parseFloat(filterFisheyeStrengthNum.value) || 0.5;
            appConfig.filter.aberrationAmount = parseFloat(filterAberrationNum.value) || 1.0;
            appConfig.filter.ditheringMultiply = parseFloat(filterDitheringNum.value) || 1.0;
            appConfig.filter.ditheringColorResolution = parseFloat(filterDitheringColorResolutionSelect.value) || 256.0;
            appConfig.filter.pixelGridSize = parseInt(filterPixelGridSizeSelect.value) || 8;
            appConfig.filter.bloomStrength = parseFloat(filterBloomStrengthNum.value) || 0.8;
            appConfig.filter.bloomRadius = parseFloat(filterBloomRadiusNum.value) || 0.5;
            appConfig.filter.bloomThreshold = parseFloat(filterBloomThresholdNum.value) || 0.6;
            appConfig.filter.brightness = parseFloat(filterBrightnessNum.value) || 0.0;
            appConfig.filter.contrast = parseFloat(filterContrastNum.value) || 1.0;
            appConfig.filter.saturation = parseFloat(filterSaturationNum.value) || 1.0;
            appConfig.filter.hueOffset = parseFloat(filterHueOffsetNum.value) || 0.0;
            appConfig.filter.gamma = parseFloat(filterGammaNum.value) || 2.2;

            // Update model-specific properties
            // IMPORTANT: Iterate through the appConfig.models array and update *those* objects
            // Do NOT re-read from UI elements that might be re-rendered and lose focus.
            appConfig.models.forEach((model) => {
                // Ensure model is valid before processing its UI elements
                if (!model || typeof model.id !== 'string') {
                    console.warn(`updateConfigFromUI: 跳过 appConfig.models 中的无效模型: ${model}`);
                    return;
                }

                // Retrieve the current values from the UI elements for this specific model
                const modelCard = document.getElementById(`model-card-${model.id}`);
                if (modelCard) {
                    const modelTypeSelect = modelCard.querySelector(`#model-type-${model.id}`);
                    const modelMaterialTypeSelect = modelCard.querySelector(`#model-material-type-${model.id}`);
                    const modelColorInput = modelCard.querySelector(`#model-color-${model.id}`);
                    const posXNum = modelCard.querySelector(`#model-pos-x-num-${model.id}`);
                    const posYNum = modelCard.querySelector(`#model-pos-y-num-${model.id}`);
                    const posZNum = modelCard.querySelector(`#model-pos-z-num-${model.id}`);
                    const scaleXNum = modelCard.querySelector(`#model-scale-x-num-${model.id}`);
                    const scaleYNum = modelCard.querySelector(`#model-scale-y-num-${model.id}`);
                    const scaleZNum = modelCard.querySelector(`#model-scale-z-num-${model.id}`);
                    const rotXNum = modelCard.querySelector(`#model-rot-x-num-${model.id}`);
                    const rotYNum = modelCard.querySelector(`#model-rot-y-num-${model.id}`);
                    const rotZNum = modelCard.querySelector(`#model-rot-z-num-${model.id}`);
                    const modelModelUrlInput = modelCard.querySelector(`#model-modelUrl-${model.id}`); // New model URL input
                    const modelActionUrlInput = modelCard.querySelector(`#model-actionUrl-${model.id}`); // New action URL input
                    const modelCastShadowToggle = modelCard.querySelector(`#model-cast-shadow-${model.id}`);
                    const modelReceiveShadowToggle = modelCard.querySelector(`#model-receive-shadow-${model.id}`);


                    // Update model config with values from UI (use existing value as fallback)
                    model.type = modelTypeSelect?.value || model.type;
                    model.materialType = modelMaterialTypeSelect?.value || model.materialType;
                    // Only update color if not GLTF
                    if (model.type !== 'GLTF') {
                        model.color = modelColorInput?.value || model.color;
                    }
                    model.position[0] = parseFloat(posXNum?.value) || model.position[0];
                    model.position[1] = parseFloat(posYNum?.value) || model.position[1];
                    model.position[2] = parseFloat(posZNum?.value) || model.position[2];

                    model.scale[0] = parseFloat(scaleXNum?.value) || model.scale[0];
                    model.scale[1] = parseFloat(scaleYNum?.value) || model.scale[1];
                    model.scale[2] = parseFloat(scaleZNum?.value) || model.scale[2];

                    model.rotation[0] = THREE.MathUtils.degToRad(parseFloat(rotXNum?.value) || 0); // Convert degrees to radians for config
                    model.rotation[1] = THREE.MathUtils.degToRad(parseFloat(rotYNum?.value) || 0);
                    model.rotation[2] = THREE.MathUtils.degToRad(parseFloat(rotZNum?.value) || 0);

                    model.modelUrl = modelModelUrlInput?.value || model.modelUrl; // Update model URL
                    model.actionUrl = modelActionUrlInput?.value || model.actionUrl; // Update action URL
                    model.castShadow = modelCastShadowToggle?.checked || false;
                    model.receiveShadow = modelReceiveShadowToggle?.checked || false;

                    // Toon properties only if materialType is Toon and not GLTF
                    if (model.materialType === 'Toon' && model.type !== 'GLTF') {
                        const toonShadowColorInput = modelCard.querySelector(`#toon-shadow-color-${model.id}`);
                        const toonBaseColorInput = modelCard.querySelector(`#toon-base-color-${model.id}`);
                        const toonHighlightColorInput = modelCard.querySelector(`#toon-highlight-color-${model.id}`);
                        const toonShadowThresholdNum = modelCard.querySelector(`#toon-shadow-threshold-num-${model.id}`);
                        const toonHighlightThresholdNum = modelCard.querySelector(`#toon-highlight-threshold-num-${model.id}`);
                        const toonSmoothnessNum = modelCard.querySelector(`#toon-smoothness-num-${model.id}`);

                        model.toonShadowColor = toonShadowColorInput?.value || model.toonShadowColor;
                        model.toonBaseColor = toonBaseColorInput?.value || model.toonBaseColor;
                        model.toonHighlightColor = toonHighlightColorInput?.value || model.toonHighlightColor;
                        model.toonShadowThreshold = parseFloat(toonShadowThresholdNum?.value) || model.toonShadowThreshold;
                        model.toonHighlightThreshold = parseFloat(toonHighlightThresholdNum?.value) || model.toonHighlightThreshold;
                        model.toonSmoothness = parseFloat(toonSmoothnessNum?.value) || model.toonSmoothness;
                    }

                } else {
                    console.warn(`updateConfigFromUI: 未找到模型卡片 ID: ${model.id}。保留现有配置值。`);
                }
            });

            updateFilterControlsState();
            updateBackgroundModeUI(); // Ensure background UI is updated after config change
            updateFogControlsState(); // Ensure fog UI is updated
            updateSSAOControlsState(); // Ensure SSAO UI is updated

            if (sceneInitialized) {
                console.log('updateConfigFromUI: 场景已初始化，触发 updateSceneParameters。');
                updateSceneParameters();
            } else {
                console.log('updateConfigFromUI: 场景尚未初始化，参数将在初始化时应用。');
            }
        }

        /**
         * Updates the enabled/disabled state of filter parameter inputs based on filter toggle states.
         */
        function updateFilterControlsState() {
            const toggleInputs = (parentId, enabled) => {
                const parentDiv = document.getElementById(parentId);
                if (parentDiv) {
                    parentDiv.querySelectorAll('input, select').forEach(input => {
                        input.disabled = !enabled;
                        input.style.opacity = enabled ? '1' : '0.5';
                        input.style.cursor = enabled ? 'auto' : 'not-allowed';
                    });
                }
            };

            toggleInputs('fisheye-controls', appConfig.filter.fisheyeEnabled);
            toggleInputs('aberration-controls', appConfig.filter.aberrationEnabled);
            toggleInputs('dithering-controls', appConfig.filter.ditheringEnabled);
            toggleInputs('pixel-controls', appConfig.filter.pixelEnabled);
            toggleInputs('bloom-controls', appConfig.filter.bloomEnabled);
            toggleInputs('color-grading-controls', appConfig.filter.colorGradingEnabled);
        }

        /**
         * Updates the visibility of background mode controls in the UI.
         */
        function updateBackgroundModeUI() {
            const mode = backgroundModeSelect.value;
            solidColorControlsDiv.classList.add('hidden');
            gradientColorControlsDiv.classList.add('hidden');
            hdrControlsDiv.classList.add('hidden');

            if (mode === 'color') {
                solidColorControlsDiv.classList.remove('hidden');
            } else if (mode === 'gradient') {
                gradientColorControlsDiv.classList.remove('hidden');
            } else if (mode === 'hdr') {
                hdrControlsDiv.classList.remove('hidden');
            }
        }

        /**
         * Updates the enabled/disabled state of fog parameter inputs based on fog toggle state.
         */
        function updateFogControlsState() {
            const enabled = appConfig.fog.enabled;
            if (fogControlsDiv) {
                fogControlsDiv.querySelectorAll('input, select').forEach(input => {
                    input.disabled = !enabled;
                    input.style.opacity = enabled ? '1' : '0.5';
                    input.style.cursor = enabled ? 'auto' : 'not-allowed';
                });
            }
        }

        /**
         * Updates the enabled/disabled state of SSAO parameter inputs based on SSAO toggle state.
         */
        function updateSSAOControlsState() {
            const enabled = appConfig.ambientOcclusion.enabled;
            if (ssaoControlsDiv) {
                ssaoControlsDiv.querySelectorAll('input, select').forEach(input => {
                    input.disabled = !enabled;
                    input.style.opacity = enabled ? '1' : '0.5';
                    input.style.cursor = enabled ? 'auto' : 'not-allowed';
                });
            }
        }


        /**
         * Generates and triggers download of the config.json file.
         */
        function generateAndDownloadConfig() {
            updateConfigFromUI();
            const jsonString = JSON.stringify(appConfig, null, 2);

            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessageBox('config.json 已生成并下载！');
            console.log('已生成并下载 config.json。');
        }

        /**
         * Displays a custom message box (instead of alert).
         * @param {string} message The message to display.
         */
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'fixed bottom-5 left-1/2 -translate-x-1/2 bg-gray-700 text-white px-5 py-2.5 rounded-lg shadow-xl text-base opacity-0 transform translate-y-4 transition-all duration-300 ease-out z-[1001]';
            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                messageBox.style.opacity = '1';
                messageBox.style.transform = 'translate(-50%, 0)';
            }, 10);

            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.style.transform = 'translate(-50%, 20px)';
                messageBox.addEventListener('transitionend', () => messageBox.remove());
            }, 3000);
            console.log('消息框已显示:', message);
        }

        /**
         * Toggles the visibility of the controls panel.
         */
        function toggleControlsPanel() {
            isPanelVisible = !isPanelVisible;
            const webglCanvas = document.getElementById('webgl-canvas'); // Get canvas element
            console.log(`toggleControlsPanel: new isPanelVisible = ${isPanelVisible}`);
            if (isPanelVisible) {
                controlsPanel.classList.add('active');
                if (webglCanvas) {
                    webglCanvas.style.pointerEvents = 'none'; // Disable pointer events on canvas when panel is active
                }
                // If there's a selected object and it's still in the scene, re-attach TransformControls when panel is visible
                if (selectedObject && selectedObject.parent && transformControls) {
                    transformControls.attach(selectedObject);
                    transformControls.setMode('translate');
                    transformControls.visible = true;
                    console.log(`面板打开: TransformControls 已附加到 ${selectedObject.userData.configId}。`);
                } else {
                    console.log(`面板打开: 无选中对象或 TransformControls 不可用。`);
                }
                console.log('控制面板现在可见。');
            } else {
                controlsPanel.classList.remove('active');
                if (webglCanvas) {
                    webglCanvas.style.pointerEvents = 'auto'; // Enable pointer events on canvas when panel is hidden
                }
                // If there's a selected object, detach TransformControls when panel is hidden
                if (transformControls && transformControls.object) {
                    transformControls.detach();
                    transformControls.visible = false;
                    console.log('面板关闭: TransformControls 已分离。');
                }
                console.log('控制面板现在隐藏。');
            }
        }

        /**
         * Saves the current camera view as the default.
         */
        function setDefaultCameraView() {
            appConfig.cameraDefault = {
                fov: camera.fov,
                position: camera.position.toArray()
            };
            showMessageBox('当前相机视图已保存为默认。');
            console.log('Current camera view saved as default:', appConfig.cameraDefault);
        }

        /**
         * Resets the camera view to the default position.
         */
        function resetCameraView() {
            if (controls) {
                // Reset OrbitControls to default
                controls.reset();
                // Apply stored default camera parameters
                camera.position.fromArray(appConfig.cameraDefault.position);
                camera.fov = appConfig.cameraDefault.fov;
                camera.updateProjectionMatrix();
                // Manually update UI elements
                document.getElementById('camera-fov-num').value = appConfig.cameraDefault.fov;
                document.getElementById('camera-fov-range').value = appConfig.cameraDefault.fov;
                document.getElementById('camera-pos-x-num').value = appConfig.cameraDefault.position[0];
                document.getElementById('camera-pos-x-range').value = appConfig.cameraDefault.position[0];
                document.getElementById('camera-pos-y-num').value = appConfig.cameraDefault.position[1];
                document.getElementById('camera-pos-y-range').value = appConfig.cameraDefault.position[1];
                document.getElementById('camera-pos-z-num').value = appConfig.cameraDefault.position[2];
                document.getElementById('camera-pos-z-range').value = appConfig.cameraDefault.position[2];
                showMessageBox('相机视图已重置为默认。');
                console.log('相机视图已重置为默认值。');
            }
        }


        // --- Event Listeners and Initial Setup ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOMContentLoaded: 初始化 UI 元素。');
            controlsPanel = document.getElementById('controls-panel');
            adminControlsContent = document.getElementById('admin-controls-content');
            const webglCanvas = document.getElementById('webgl-canvas'); // Get canvas element

            if (!controlsPanel) {
                console.error('错误: 未找到 #controls-panel 元素!');
                return;
            }
            if (!adminControlsContent) {
                console.error('错误: 未找到 #admin-controls-content 元素!');
                return;
            }
            if (!webglCanvas) {
                console.error('错误: 未找到 #webgl-canvas 元素!');
                return;
            }

            console.log('找到控制面板元素:', controlsPanel);
            console.log('找到管理员控制内容元素:', adminControlsContent);
            console.log('找到 Canvas 元素:', webglCanvas);

            // Initialize top panel buttons
            const toggleBtn = document.getElementById('toggle-controls');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleControlsPanel);
                console.log('已添加切换控制按钮监听器。');
            } else {
                console.warn('未找到切换控制按钮。');
            }
            
            const resetViewBtn = document.getElementById('reset-view');
            if (resetViewBtn) {
                resetViewBtn.addEventListener('click', resetCameraView);
                console.log('已添加重置视图按钮监听器。');
            } else {
                console.warn('未找到重置视图按钮。');
            }

            const setDefaultViewBtn = document.getElementById('set-default-view');
            if (setDefaultViewBtn) {
                setDefaultViewBtn.addEventListener('click', setDefaultCameraView);
                console.log('已添加设置默认视图按钮监听器。');
            } else {
                console.warn('未找到设置默认视图按钮。');
            }


            cameraFovNum = document.getElementById('camera-fov-num');
            cameraFovRange = document.getElementById('camera-fov-range');
            cameraPosXNum = document.getElementById('camera-pos-x-num');
            cameraPosXRange = document.getElementById('camera-pos-x-range');
            cameraPosYNum = document.getElementById('camera-pos-y-num');
            cameraPosYRange = document.getElementById('camera-pos-y-range');
            cameraPosZNum = document.getElementById('camera-pos-z-num');
            cameraPosZRange = document.getElementById('camera-pos-z-range');

            fogEnabledToggle = document.getElementById('fog-enabled');
            fogColorInput = document.getElementById('fog-color');
            fogOpacityNum = document.getElementById('fog-opacity-num'); // Get opacity inputs
            fogOpacityRange = document.getElementById('fog-opacity-range'); // Get opacity inputs
            fogNearNum = document.getElementById('fog-near-num');
            fogNearRange = document.getElementById('fog-near-range');
            fogFarNum = document.getElementById('fog-far-num');
            fogFarRange = document.getElementById('fog-far-range');
            fogControlsDiv = document.getElementById('fog-controls');

            backgroundModeSelect = document.getElementById('background-mode');
            sceneBackgroundColor = document.getElementById('scene-background-color');
            gradientColor1 = document.getElementById('gradient-color1');
            gradientColor2 = document.getElementById('gradient-color2');
            hdrUploadInput = document.getElementById('hdr-upload');
            displayHdrAsBackgroundToggle = document.getElementById('display-hdr-as-background');
            solidColorControlsDiv = document.getElementById('solid-color-controls');
            gradientColorControlsDiv = document.getElementById('gradient-color-controls');
            hdrControlsDiv = document.getElementById('hdr-controls');

            lightAmbientNum = document.getElementById('light-ambient-intensity-num');
            lightAmbientRange = document.getElementById('light-ambient-intensity-range');
            ambientLightColor = document.getElementById('ambient-light-color'); // Get new ambient color input
            lightDirectionalNum = document.getElementById('light-directional-intensity-num');
            lightDirectionalRange = document.getElementById('light-directional-intensity-range');
            directionalLightColor = document.getElementById('directional-light-color'); // Get new directional color input
            lightDirPosXNum = document.getElementById('light-dir-pos-x-num');
            lightDirPosXRange = document.getElementById('light-dir-pos-x-range');
            lightDirPosYNum = document.getElementById('light-dir-pos-y-num');
            lightDirPosYRange = document.getElementById('light-dir-pos-y-range');
            lightDirPosZNum = document.getElementById('light-dir-pos-z-num');
            lightDirPosZRange = document.getElementById('light-dir-pos-z-range');

            ssaoEnabledToggle = document.getElementById('ssao-enabled');
            ssaoRadiusNum = document.getElementById('ssao-radius-num');
            ssaoRadiusRange = document.getElementById('ssao-radius-range');
            ssaoIntensityNum = document.getElementById('ssao-intensity-num');
            ssaoIntensityRange = document.getElementById('ssao-intensity-range');
            ssaoBiasNum = document.getElementById('ssao-bias-num');
            ssaoBiasRange = document.getElementById('ssao-bias-range');
            ssaoControlsDiv = document.getElementById('ssao-controls');


            modelListDiv = document.getElementById('model-list');
            uploadModelBtn = document.getElementById('upload-model-btn');
            addPrimitiveModelBtn = document.getElementById('add-primitive-model-btn'); // New button
            clearAllModelsBtn = document.getElementById('clear-all-models-btn');

            hoverScaleFactorNum = document.getElementById('hover-scale-factor-num');
            hoverScaleFactorRange = document.getElementById('hover-scale-factor-range');
            hoverDurationNum = document.getElementById('hover-duration-num');
            hoverDurationRange = document.getElementById('hover-duration-range');
            hoverEmissiveIntensityNum = document.getElementById('hover-emissive-intensity-num');
            hoverEmissiveIntensityRange = document.getElementById('hover-emissive-intensity-range');

            filterFisheyeEnabled = document.getElementById('filter-fisheye-enabled');
            filterFisheyeStrengthNum = document.getElementById('filter-fisheye-strength-num');
            filterFisheyeStrengthRange = document.getElementById('filter-fisheye-strength-range');

            filterAberrationEnabled = document.getElementById('filter-aberration-enabled');
            filterDitheringEnabled = document.getElementById('filter-dithering-enabled');
            filterPixelEnabled = document.getElementById('filter-pixel-enabled');
            filterBloomEnabled = document.getElementById('filter-bloom-enabled');
            filterColorGradingEnabled = document.getElementById('filter-color-grading-enabled');

            filterAberrationNum = document.getElementById('filter-aberration-num');
            filterAberrationRange = document.getElementById('filter-aberration-range');
            filterDitheringNum = document.getElementById('filter-dithering-num');
            filterDitheringRange = document.getElementById('filter-dithering-range');
            filterDitheringColorResolutionSelect = document.getElementById('filter-dithering-color-resolution');
            filterPixelGridSizeSelect = document.getElementById('filter-pixel-grid-size');
            filterBloomStrengthNum = document.getElementById('filter-bloom-strength-num');
            filterBloomStrengthRange = document.getElementById('filter-bloom-strength-range');
            filterBloomRadiusNum = document.getElementById('filter-bloom-radius-num');
            filterBloomRadiusRange = document.getElementById('filter-bloom-radius-range');
            filterBloomThresholdNum = document.getElementById('filter-bloom-threshold-num');
            filterBloomThresholdRange = document.getElementById('filter-bloom-threshold-range');

            filterBrightnessNum = document.getElementById('filter-brightness-num');
            filterBrightnessRange = document.getElementById('filter-brightness-range');
            filterContrastNum = document.getElementById('filter-contrast-num');
            filterContrastRange = document.getElementById('filter-contrast-range');
            filterSaturationNum = document.getElementById('filter-saturation-num');
            filterSaturationRange = document.getElementById('filter-saturation-range');
            filterHueOffsetNum = document.getElementById('filter-hue-offset-num');
            filterHueOffsetRange = document.getElementById('filter-hue-offset-range');
            filterGammaNum = document.getElementById('filter-gamma-num');
            filterGammaRange = document.getElementById('filter-gamma-range');
            
            generateConfigBtn = document.getElementById('generate-config-btn');

            setupSliderNumberInput('camera-fov', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('camera-pos-x', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('camera-pos-y', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('camera-pos-z', debouncedUpdateConfigFromUI);

            fogEnabledToggle.addEventListener('change', updateConfigFromUI);
            fogColorInput.addEventListener('input', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('fog-opacity', debouncedUpdateConfigFromUI); // Link opacity inputs
            setupSliderNumberInput('fog-near', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('fog-far', debouncedUpdateConfigFromUI);

            backgroundModeSelect.addEventListener('change', updateConfigFromUI);
            sceneBackgroundColor.addEventListener('input', debouncedUpdateConfigFromUI);
            gradientColor1.addEventListener('input', debouncedUpdateConfigFromUI);
            gradientColor2.addEventListener('input', debouncedUpdateConfigFromUI);
            displayHdrAsBackgroundToggle.addEventListener('change', updateConfigFromUI);
            
            hdrUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) {
                    appConfig.background.hdrUrl = '';
                    debouncedUpdateConfigFromUI();
                    showMessageBox('HDR 环境图已清除。');
                    return;
                }

                const hdrLoaderStatus = document.getElementById('hdr-loader-status');
                hdrLoaderStatus.classList.remove('hidden');
                new RGBELoader()
                    .load(URL.createObjectURL(file), (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = texture;
                        appConfig.background.hdrUrl = URL.createObjectURL(file);
                        debouncedUpdateConfigFromUI();
                        hdrLoaderStatus.classList.add('hidden');
                        showMessageBox('HDR 环境图加载成功!');
                    })
                    .catch((err) => {
                        console.error('HDR 加载失败:', err);
                        showMessageBox(`HDR 加载失败: ${err.message.substring(0, 100)}...`);
                        hdrLoaderStatus.classList.add('hidden');
                    });
            });


            setupSliderNumberInput('light-ambient-intensity', debouncedUpdateConfigFromUI);
            ambientLightColor.addEventListener('input', debouncedUpdateConfigFromUI); // Ambient color listener
            setupSliderNumberInput('light-directional-intensity', debouncedUpdateConfigFromUI);
            directionalLightColor.addEventListener('input', debouncedUpdateConfigFromUI); // Directional color listener
            setupSliderNumberInput('light-dir-pos-x', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('light-dir-pos-y', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('light-dir-pos-z', debouncedUpdateConfigFromUI);

            ssaoEnabledToggle.addEventListener('change', updateConfigFromUI);
            setupSliderNumberInput('ssao-radius', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('ssao-intensity', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('ssao-bias', debouncedUpdateConfigFromUI);

            setupSliderNumberInput('hover-scale-factor', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('hover-duration', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('hover-emissive-intensity', debouncedUpdateConfigFromUI);

            filterFisheyeEnabled.addEventListener('change', updateConfigFromUI);
            setupSliderNumberInput('filter-fisheye-strength', debouncedUpdateConfigFromUI);

            filterAberrationEnabled.addEventListener('change', updateConfigFromUI);
            setupSliderNumberInput('filter-aberration', debouncedUpdateConfigFromUI);
            filterDitheringEnabled.addEventListener('change', updateConfigFromUI);
            setupSliderNumberInput('filter-dithering', debouncedUpdateConfigFromUI);
            filterDitheringColorResolutionSelect.addEventListener('change', debouncedUpdateConfigFromUI);
            filterPixelEnabled.addEventListener('change', updateConfigFromUI);
            filterPixelGridSizeSelect.addEventListener('change', debouncedUpdateConfigFromUI);

            filterBloomEnabled.addEventListener('change', updateConfigFromUI);
            setupSliderNumberInput('filter-bloom-strength', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('filter-bloom-radius', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('filter-bloom-threshold', debouncedUpdateConfigFromUI);

            filterColorGradingEnabled.addEventListener('change', updateConfigFromUI);
            setupSliderNumberInput('filter-brightness', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('filter-contrast', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('filter-saturation', debouncedUpdateConfigFromUI);
            setupSliderNumberInput('filter-hue-offset', debouncedUpdateConfigFromUI);
            filterGammaNum.value = appConfig.filter.gamma;
            filterGammaRange.value = appConfig.filter.gamma;
            setupSliderNumberInput('filter-gamma', debouncedUpdateConfigFromUI);
            
            uploadModelBtn.addEventListener('click', uploadModel);
            addPrimitiveModelBtn.addEventListener('click', addPrimitiveModel); // New button listener
            clearAllModelsBtn.addEventListener('click', clearAllModels);
            generateConfigBtn.addEventListener('click', generateAndDownloadConfig);

            console.log('尝试加载初始配置...');
            await loadInitialConfig();
            console.log('初始配置已加载。AppConfig:', appConfig);

            console.log('尝试初始化 Three.js...');
            initThreeJS();
            console.log('Three.js 初始化完成。');

            // Panel is now hidden by default. User must click "配置面板" or use shortcut to open.
            controlsPanel.classList.remove('active'); 
            isPanelVisible = false;
            webglCanvas.style.pointerEvents = 'auto'; // Ensure canvas receives events by default
            console.log('控制面板类 "active" 已移除。当前类:', controlsPanel.classList);
            console.log('isPanelVisible:', isPanelVisible);


            document.querySelectorAll('.collapsible-header').forEach(header => {
                const targetId = header.dataset.target;
                const contentDiv = document.getElementById(targetId);
                const arrowIcon = header.querySelector('.arrow-icon');
                
                if (contentDiv) {
                    // Set all collapsible content to active by default so initial scrollHeight is correct
                    // Then collapse them if they are not meant to be open
                    contentDiv.classList.add('active'); 
                    if (arrowIcon) {
                        arrowIcon.classList.add('rotate-90');
                    }
                    contentDiv.style.maxHeight = contentDiv.scrollHeight + 'px'; // Set to full height first
                    
                    // After initial display, set to 0 to make them collapsible
                    // This is for proper animation, but they start "open" visually initially
                    // You might want to adjust this if you want them truly closed on page load
                    // For now, they are technically "active" but styled to be open for UI rendering
                    // If you want them collapsed by default, remove the above 'active' class and 'rotate-90'
                    // and ensure maxHeight is '0' initially.
                    
                    header.addEventListener('click', () => {
                        toggleCollapsible(contentDiv, arrowIcon);
                    });
                } else {
                    console.warn(`未找到目标 ID 为 ${targetId} 的可折叠内容 div。`);
                }
            });
            
            renderUI();
            console.log('UI 渲染完成。场景已就绪。');
        });

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.altKey && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                toggleControlsPanel();
            }
            if (transformControls && selectedObject) {
                switch (e.key) {
                    case 'w':
                        transformControls.setMode('translate');
                        console.log('TransformControls 模式设置为 Translate。');
                        break;
                    case 'e':
                        transformControls.setMode('rotate');
                        console.log('TransformControls 模式设置为 Rotate。');
                        break;
                    case 'r':
                        transformControls.setMode('scale');
                        console.log('TransformControls 模式设置为 Scale。');
                        break;
                }
            }
        });
    </script>
</body>
</html>
